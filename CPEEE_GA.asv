% CPEEE 2026 — Energy-aware truck–drone logistics (Genetic Algorithm Version)
%
% This script uses a new, robust two-stage optimization process.
%
% --- NEW HIERARCHY ---
% Stage 1: Grid Optimization (Master Problem)
%   - The model first determines the maximum amount of drone energy that can be
%     recharged over 24 hours without violating any power grid constraints.
%   - This is done using a bisection search that repeatedly checks charging
%     schedules against the MATPOWER grid oracle.
%   - The result is a hard, physically-based "feasible energy budget".
%
% Stage 2: Logistics Optimization (Subproblem)
%   - The Genetic Algorithm then solves the delivery problem to minimize cost.
%   - It is given a new, critical constraint: the total energy required by its
%     chosen drone sorties cannot exceed the feasible budget from Stage 1.
%   - This guarantees that the final solution is not only low-cost but also
%     electrically feasible.
function main(nCust, nTrucks, nDrones)
    % --- Main execution function ---
    if nargin < 1, nCust   = 100; end
    if nargin < 2, nTrucks = 10;  end
    if nargin < 3, nDrones = 20;  end
    
    close all; clc;
    addpath(genpath(fullfile(pwd,'matpower8.1')));
    
    inst = demoInstance(nCust, nTrucks, nDrones);
    
    % --- Analyze baseline grid stress before starting optimization ---
    fprintf('--- Baseline Grid Headroom Analysis ---\n');
    analyzeGridHeadroom(inst);
    
    % --- STAGE 1: Find the maximum feasible energy budget for the grid ---
    fprintf('--- Stage 1: Determining Maximum Feasible Drone Energy Budget ---\n');
    maxFeasibleEnergy = findMaxFeasibleEnergy(inst);
    fprintf('Maximum feasible drone energy for this scenario: %.2f kWh.\n\n', maxFeasibleEnergy);
    % --- Added a warning for a zero-energy budget ---
    if maxFeasibleEnergy < 0.1
        fprintf('WARNING: The feasible energy budget is zero. The grid cannot support drone charging.\n');
        fprintf('         The GA will be forced to use trucks only, resulting in a high penalty score.\n\n');
    end
    % --- STAGE 2: Solve logistics with the GA under the energy budget ---
    fprintf('--- Stage 2: Optimizing Logistics Within Feasible Budget ---\n');
    [bestIndividual, bestFitness] = runGA(inst, maxFeasibleEnergy);
    % --- Decode, Report, and Visualize the final, feasible solution ---
    sol = decodeGAIndividual(inst, bestIndividual);
    
    fprintf('\n--- Final Feasible Solution Found ---\n');
    fprintf('Best objective: %.3f\n', bestFitness);
    comps = objectiveBreakdown(inst, sol);
    fprintf('Objective breakdown => Truck: %.3f, Energy: %.3f, DroneBonus: %.3f, Total(est): %.3f\n', ...
    comps.truck, comps.energy, comps.droneBonus, comps.truck+comps.energy+comps.droneBonus);
    reportSolution(sol);
    
    plotChargingAndTariff(inst, sol);
    plotScenario(inst, sol);
    plotGridWithScenario(inst, sol);
    plotGanttIfAvailable(inst, sol);
    saveFiguresAndData(inst, sol, [], false);
end
% ========= Grid Analysis Function =========
function analyzeGridHeadroom(inst)
    mpc = inst.ps.mpc;
    try
        r_base = runopf(mpc, mpoption('verbose',0,'out.all',0));
        if ~r_base.success, fprintf('Baseline OPF failed.\n'); return; end
        
        S_flow = hypot(r_base.branch(:,14), r_base.branch(:,15));
        rate = r_base.branch(:,6); rate(rate == 0) = Inf;
        loading = (S_flow ./ rate) * 100;
        [max_loading, most_stressed_idx] = max(loading);
        from_bus = r_base.branch(most_stressed_idx, 1);
        to_bus = r_base.branch(most_stressed_idx, 2);
        
        fprintf('Most stressed line is from Bus %d to Bus %d.\n', from_bus, to_bus);
        fprintf('Baseline loading on this line: %.2f%% of its thermal limit.\n', max_loading);
        
        headroom_kw = 0; step_kw = 10;
        for add_kw = step_kw:step_kw:5000
            mpc_test = mpc;
            mpc_test.bus(mpc_test.bus(:,1) == inst.ps.depotBus, 3) = ...
                mpc_test.bus(mpc_test.bus(:,1) == inst.ps.depotBus, 3) + add_kw / 1000;
            
            r_test = runopf(mpc_test, mpoption('verbose',0,'out.all',0));
            if ~r_test.success, break; end 
            
            S_flow_test = hypot(r_test.branch(:,14), r_test.branch(:,15));
            if any(S_flow_test > rate), break; end
            
            headroom_kw = add_kw;
        end
        fprintf('Estimated grid headroom at Depot Bus %d: %.2f kW.\n\n', inst.ps.depotBus, headroom_kw);
    catch e
        fprintf('Could not perform grid headroom analysis. Error: %s\n', e.message);
    end
end
% ========= Stage 1 Function =========
function maxEnergy = findMaxFeasibleEnergy(inst)
    lowEnergy = 0; highEnergy = sum(inst.e_sortie); maxEnergy = 0;
    fprintf('Searching for energy budget between %.2f and %.2f kWh...\n', lowEnergy, highEnergy);
    
    for i = 1:10 
        midEnergy = (lowEnergy + highEnergy) / 2;
        fprintf('  Iter %d: Testing energy budget of %.2f kWh...', i, midEnergy);
        
        Pdepot_test = scheduleCharging(inst, midEnergy);
        [feasible, ~, ~] = gridCheckMatpower(inst, struct('Pdepot', Pdepot_test'));
        
        if feasible
            fprintf(' FEASIBLE. New range: [%.2f, %.2f]\n', midEnergy, highEnergy);
            maxEnergy = midEnergy;
            lowEnergy = midEnergy;
        else
            fprintf(' INFEASIBLE. New range: [%.2f, %.2f]\n', lowEnergy, midEnergy);
            highEnergy = midEnergy;
        end
    end
end
% ========= Genetic Algorithm Core Functions (Stage 2) =========
function [bestIndividual, bestFitness] = runGA(inst, maxFeasibleEnergy)
    popSize = 100; nGen = 300; crossoverRate = 0.8; mutationRate = 0.1; tournamentSize = 5;
    population = createInitialPopulation(inst, popSize);
    fitness = zeros(popSize, 1);
    for i = 1:popSize
        fitness(i) = calculateFitness(inst, population{i}, maxFeasibleEnergy);
    end
    [bestFitness, bestIdx] = min(fitness);
    bestIndividual = population{bestIdx};
    for gen = 1:nGen
        newPopulation = cell(popSize, 1);
        for i = 1:2:popSize
            parent1 = selection(population, fitness, tournamentSize);
            parent2 = selection(population, fitness, tournamentSize);
            if rand < crossoverRate, [child1, child2] = crossover(parent1, parent2, inst);
            else, child1 = parent1; child2 = parent2; end
            child1 = mutation(child1, inst, mutationRate);
            child2 = mutation(child2, inst, mutationRate);
            newPopulation{i} = child1;
            newPopulation{i+1} = child2;
        end
        population = newPopulation;
        
        for i = 1:popSize, fitness(i) = calculateFitness(inst, population{i}, maxFeasibleEnergy); end
        
        [currentBestFitness, currentBestIdx] = min(fitness);
        if currentBestFitness < bestFitness
            bestFitness = currentBestFitness;
            bestIndividual = population{currentBestIdx};
        end
        if mod(gen, 50) == 0, fprintf('Generation %d: Best fitness = %.3f\n', gen, bestFitness); end
    end
end
function population = createInitialPopulation(inst, popSize)
    population = cell(popSize, 1);
    for i = 1:popSize
        droneCust = find(inst.insideC1)'; 
        other_cust = find(~inst.insideC1)';
        
        if isempty(other_cust) 
            num_other_drones = 0;
            drone_extras = [];
        else
            num_other_drones = randi([0, numel(other_cust)]);
            drone_extras = randsample(other_cust, num_other_drones);
        end
        
        droneCust = [droneCust, drone_extras];
        truckCust = setdiff(1:inst.nCust, droneCust);
        
        assignments = cell(inst.nTrucks, 1);
        if ~isempty(truckCust)
            truckIdx = randi(inst.nTrucks, 1, numel(truckCust));
            for j = 1:numel(truckCust), assignments{truckIdx(j)}(end+1) = truckCust(j); end
        end
        individual.truckAssignments = assignments;
        individual.droneAssignments = droneCust;
        population{i} = individual;
    end
end
function fitness = calculateFitness(inst, individual, maxFeasibleEnergy)
    truckCost = 0;
    for i = 1:inst.nTrucks
        route = individual.truckAssignments{i};
        if ~isempty(route)
            truckCost = truckCost + inst.d(1, route(1)+1);
            for j = 1:length(route)-1, truckCost = truckCost + inst.d(route(j)+1, route(j+1)+1); end
            truckCost = truckCost + inst.d(route(end)+1, 1);
        end
    end
    truckCost = truckCost * inst.cTruckKm;
    
    droneBonus = numel(individual.droneAssignments) * inst.droneIncentive;
    
    totalEnergyNeeded = sum(inst.e_sortie(individual.droneAssignments));
    Pdepot = scheduleCharging(inst, totalEnergyNeeded);
    energyCost = sum(Pdepot' .* inst.ps.tariff) * inst.dt;
    
    energyBudgetPenalty = 0;
    if totalEnergyNeeded > maxFeasibleEnergy, energyBudgetPenalty = (totalEnergyNeeded - maxFeasibleEnergy) * 1e7; end
    
    max_sorties = inst.nDrones * inst.droneMaxSorties;
    sortiePenalty = 0;
    if numel(individual.droneAssignments) > max_sorties
        sortiePenalty = (numel(individual.droneAssignments) - max_sorties) * 1e8;
    end
    
    fitness = truckCost + droneBonus + energyCost + energyBudgetPenalty + sortiePenalty;
end
function Pdepot = scheduleCharging(inst, totalEnergyNeeded)
    Pdepot = zeros(inst.T, 1); energyCharged = 0;
    [~, sortedIdx] = sort(inst.ps.tariff);
    for i = 1:inst.T
        k = sortedIdx(i);
        chargePower = min(inst.ps.PcapDepot(k), (totalEnergyNeeded - energyCharged) / (inst.etaCharge * inst.dt));
        if chargePower > 1e-6, Pdepot(k) = chargePower;
            energyCharged = energyCharged + chargePower * inst.etaCharge * inst.dt; end
        if energyCharged >= totalEnergyNeeded, break; end
    end
end
function parent = selection(population, fitness, tournamentSize)
    contendersIdx = randi(length(population), tournamentSize, 1);
    [~, winnerLocalIdx] = min(fitness(contendersIdx));
    winnerIdx = contendersIdx(winnerLocalIdx);
    parent = population{winnerIdx};
end
function [child1, child2] = crossover(parent1, parent2, inst)
    child1 = parent1; child2 = parent2;
    p1_drones = parent1.droneAssignments;
    p2_drones = parent2.droneAssignments;
    drone_union = union(p1_drones, p2_drones);
    
    non_mandatory_union = setdiff(drone_union, find(inst.insideC1));
    
    if numel(non_mandatory_union) > 1
        cut_point = randi(numel(non_mandatory_union)-1);
        
        part1_c1 = non_mandatory_union(1:cut_point);
        part2_c1 = setdiff(p2_drones, non_mandatory_union(1:cut_point));
        c1_drones = [part1_c1(:)', part2_c1(:)'];
        part1_c2 = non_mandatory_union(cut_point+1:end);
        part2_c2 = setdiff(p1_drones, non_mandatory_union(cut_point+1:end));
        c2_drones = [part1_c2(:)', part2_c2(:)'];
        child1.droneAssignments = union(c1_drones, find(inst.insideC1));
        child2.droneAssignments = union(c2_drones, find(inst.insideC1));
    end
    child1 = reassign_trucks(child1, inst);
    child2 = reassign_trucks(child2, inst);
end
function individual = mutation(individual, inst, mutationRate)
    if rand > mutationRate, return; end
    truck_cust = horzcat(individual.truckAssignments{:});
    drone_cust = individual.droneAssignments;
    non_mandatory_drones = setdiff(drone_cust, find(inst.insideC1));
    
    if ~isempty(truck_cust) && ~isempty(non_mandatory_drones)
        cust_from_truck = truck_cust(randi(numel(truck_cust)));
        cust_from_drone = non_mandatory_drones(randi(numel(non_mandatory_drones)));
        individual.droneAssignments(individual.droneAssignments == cust_from_drone) = cust_from_truck;
        for i=1:inst.nTrucks
            route = individual.truckAssignments{i};
            if ismember(cust_from_truck, route)
                route(route == cust_from_truck) = cust_from_drone;
                individual.truckAssignments{i} = route; break;
            end
        end
    end
end
function individual = reassign_trucks(individual, inst)
    all_cust = 1:inst.nCust; truck_cust = setdiff(all_cust, individual.droneAssignments);
    assignments = cell(inst.nTrucks, 1);
    if ~isempty(truck_cust)
        truckIdx = randi(inst.nTrucks, 1, numel(truck_cust));
        for j = 1:numel(truck_cust), assignments{truckIdx(j)}(end+1) = truck_cust(j); end
    end
    individual.truckAssignments = assignments;
end
% ========= Instance, Decoding, and Utility Functions =========
function inst = demoInstance(nCust, nTrucks, nDrones)
    inst.nCust   = nCust; inst.nTrucks = nTrucks; inst.nDrones = nDrones;
    inst.T  = 48; inst.dt = 0.5;
    [inst.coords, inst.W, inst.tw] = tinyCustomers(inst.nCust, inst.T);
    inst.cityCenter = [0, 0]; inst.depot = [-14, 10];
    inst.vTruck = 30; inst.vDrone = 50; inst.serv = 0.05; inst.sortieFlightTime = 0.20;
    
    inst.droneRechargeTime = 1.0; 
    inst.droneMaxSorties = 4;     
    
    ps = tinyFeeder33(); ps.depotBus = 5;
    ps.tariff = 0.4 + 0.2*(sin((1:inst.T)/inst.T*2*pi - pi/2) > 0);
    ps.PcapDepot = 5.0*ones(1,inst.T);
    inst.ps = ps; inst.droneCapWh = 0.35*1000; inst.etaCharge  = 0.92;
    inst.cWh_per_km = @(w) 15 + 6*w; inst.cTruckKm   = 1.2; inst.droneIncentive = -0.05;
    inst.d = pdist2([inst.depot;inst.coords],[inst.depot;inst.coords],'euclidean');
    airDist  = 2*sqrt(sum((inst.coords - inst.depot).^2,2));
    inst.e_sortie = (inst.cWh_per_km(mean(inst.W))/1000) * airDist;
    ctr = inst.cityCenter(:)'; maxR = max(1, max(sqrt(sum((inst.coords - ctr).^2, 2))));
    r1 = 0.70*maxR; ax1 = 1.00; ay1 = 0.85; ang = deg2rad(20);
    Rrot = [cos(ang), -sin(ang); sin(ang), cos(ang)];
    X = (inst.coords - ctr) * Rrot;
    inst.insideC1 = (X(:,1)./(ax1*r1)).^2 + (X(:,2)./(ay1*r1)).^2 <= 1 + 1e-9;
end
function [coords, W, tw] = tinyCustomers(n, T_horizon)
    rng('shuffle'); coords = -12 + 24*rand(n,2); W  = 0.5 + 0.5*rand(n,1);
    tw = [zeros(n,1), T_horizon*0.5*ones(n,1)];
end
function ps = tinyFeeder33()
    mpc = case33bw(); ps.nb = size(mpc.bus, 1);
    
    unrated_lines = mpc.branch(:, 6) == 0;
    mpc.branch(unrated_lines, 6) = 5; 
    
    mpc.branch(:, 3) = mpc.branch(:, 3) * 0.5;
    mpc.branch(:, 4) = mpc.branch(:, 4) * 0.5;
    
    ps.mpc = mpc;
    
    active_branches = mpc.branch(mpc.branch(:, 11) == 1, :);
    tie_branches = mpc.branch(mpc.branch(:, 11) == 0, :);
    ps.L = active_branches(:, 1:2);
    ps.L_tie = tie_branches(:, 1:2);
    ps.Smax = 1000 * ones(ps.nb, 1);
    ps.baseLoad = mpc.bus(:, 3);
end
function sol = decodeGAIndividual(inst, individual)
    sol.mTruck = zeros(inst.nCust, 1); truck_cust = horzcat(individual.truckAssignments{:});
    sol.mTruck(truck_cust) = 1; sol.zDrone = zeros(inst.nCust, 1);
    sol.zDrone(individual.droneAssignments) = 1;
    sol.truckCust = find(sol.mTruck==1); sol.droneCust = find(sol.zDrone==1);
    totalEnergyNeeded = sum(inst.e_sortie(sol.droneCust));
    sol.Pdepot = scheduleCharging(inst, totalEnergyNeeded)';
    sol = buildLaunchRecovery(inst, sol);
end
function sol=buildLaunchRecovery(inst, sol)
    sol.launchTimes=cell(inst.nDrones,1); sol.recoverTimes=cell(inst.nDrones,1);
    drone_available_time = zeros(inst.nDrones, 1);
    
    [~, sorted_idx] = sort(inst.tw(sol.droneCust, 1));
    sorted_drone_cust = sol.droneCust(sorted_idx);
    
    for i = 1:numel(sorted_drone_cust)
        cust_idx = sorted_drone_cust(i);
        [~, drone_to_use] = min(drone_available_time);
        start_time = drone_available_time(drone_to_use);
        launch_time = max(start_time, inst.tw(cust_idx, 1));
        if launch_time + inst.sortieFlightTime > inst.tw(cust_idx, 2), continue; end
        recovery_time = launch_time + inst.sortieFlightTime;
        sol.launchTimes{drone_to_use}(end+1) = launch_time;
        sol.recoverTimes{drone_to_use}(end+1) = recovery_time;
        drone_available_time(drone_to_use) = recovery_time + inst.droneRechargeTime;
    end
end
function comps=objectiveBreakdown(inst,sol)
    truck_cust = find(sol.mTruck); truckCost = 0;
    if ~isempty(truck_cust), truckCost = inst.cTruckKm*numel(truck_cust)*mean(inst.d(1,truck_cust+1)); end
    energyCost = sum(sol.Pdepot.*inst.ps.tariff)*inst.dt;
    droneBonus = inst.droneIncentive*sum(sol.zDrone);
    comps=struct('truck',truckCost,'energy',energyCost,'droneBonus',droneBonus);
end
function [feasible,maxViol,pattern]=gridCheckMatpower(inst,sol)
    T=inst.T; bDepot=inst.ps.depotBus; feasible=true; maxViol=0; pattern=zeros(1,T);
    for k=1:T
        mpc = inst.ps.mpc; 
        Pd_add=sol.Pdepot(k)/1000; bIdx=min(bDepot,size(mpc.bus,1));
        mpc.bus(bIdx,3) = mpc.bus(bIdx,3) + Pd_add;
        try
            r=runopf(mpc, mpoption('verbose',0,'out.all',0));
            ok=isfield(r,'success')&&r.success==1; if ~ok, feasible=false; maxViol=max(maxViol,1); pattern(k)=1; continue; end
            
            if isfield(r,'branch')&&size(r.branch,2)>=15
                S=hypot(r.branch(:,14),r.branch(:,15)); 
                rate=max(1e-6,r.branch(:,6));
                
                if any(S > rate)
                    feasible = false;
                    viol_idx = find(S > rate, 1);
                    from_bus = r.branch(viol_idx, 1);
                    to_bus = r.branch(viol_idx, 2);
                    fprintf('\nViolation at t=%.1fh: Line %d-%d overloaded. Flow: %.2f MVA, Limit: %.2f MVA.', ...
                        (k-1)*inst.dt, from_bus, to_bus, S(viol_idx), rate(viol_idx));
                    maxViol = max(maxViol, max(S-rate));
                    pattern(k) = 1;
                end
            end
        catch
            feasible=false; pattern(k)=1; maxViol=max(maxViol,1);
        end
    end
end
function reportSolution(sol)
    fprintf('Truck-served customers: %s\n',mat2str(find(sol.mTruck==1)'));
    fprintf('Drone-served customers: %s\n',mat2str(find(sol.zDrone==1)'));
    fprintf('Depot peak (kW): %.2f\n',max(sol.Pdepot));
    fprintf('Depot energy (kWh): %.2f\n',sum(sol.Pdepot)*0.5);
end
function plotChargingAndTariff(inst,sol)
    figure('Name','Charging and Tariff'); t=(0:inst.T-1)*inst.dt;
    yyaxis left; stairs(t,sol.Pdepot,'LineWidth',2); hold on;
    stairs(t,inst.ps.PcapDepot,'--','LineWidth',1.2);
    ylabel('Depot charging (kW)'); ylim([0,max(inst.ps.PcapDepot)*1.2]);
    yyaxis right; plot(t,inst.ps.tariff,'Color',[0.85 0.33 0.1],'LineWidth',1.8);
    ylabel('Tariff ($/kWh)'); grid on; xlabel('Time (h)');
    title('Depot charging vs tariff and capacity'); legend('P_{depot}','Capacity','Tariff');
end
function plotScenario(inst,sol)
    figure('Name','Scenario'); scatter(inst.depot(1),inst.depot(2),120,'ks','filled'); hold on;
    C=inst.coords; idT=find(sol.mTruck==1); idD=find(sol.zDrone==1);
    scatter(C(idD,1),C(idD,2),60,'b','filled'); scatter(C(idT,1),C(idT,2),60,'r','filled');
    for i=idD(:)', plot([inst.depot(1),C(i,1)],[inst.depot(2),C(i,2)],'b:'); end
    for i=idT(:)', plot([inst.depot(1),C(i,1)],[inst.depot(2),C(i,2)],'r-'); end
    legend('Depot','Drone customers','Truck customers','Location','bestoutside');
    axis equal; grid on; xlabel('km (x)'); ylabel('km (y)');
    title('Logistics Scenario: Truck and Drone Assignments');
end
function plotGridWithScenario(inst, ~)
    nb = inst.ps.nb; [busXY, meta, inst2] = buildTokyoRingLayout(nb, inst); inst.depot = inst2.depot;
    figure('Name','Grid layout (Tokyo rings) with depot and customers');
    hold on; grid on; axis equal; hBranches = [];
    for e = 1:size(inst.ps.L,1)
        i = inst.ps.L(e,1); j = inst.ps.L(e,2);
        if i<=nb && j<=nb
            h = plot([busXY(i,1),busXY(j,1)],[busXY(i,2),busXY(j,2)],'-','Color',[0.4 0.4 0.4],'LineWidth',1.5);
            if isempty(hBranches), hBranches = h; end
        end
    end
    hTieLines = [];
    if isfield(inst.ps, 'L_tie') && ~isempty(inst.ps.L_tie)
        for e = 1:size(inst.ps.L_tie,1)
            i = inst.ps.L_tie(e,1); j = inst.ps.L_tie(e,2);
            if i<=nb && j<=nb
                h = plot([busXY(i,1),busXY(j,1)],[busXY(i,2),busXY(j,2)],':','Color',[0.6 0.6 0.6],'LineWidth',1.2);
                if isempty(hTieLines), hTieLines = h; end
            end
        end
    end
    hBuses = scatter(busXY(:,1), busXY(:,2), 25, 'k', 'filled');
    
    for i = 1:nb
        text(busXY(i,1) + 0.3, busXY(i,2) + 0.3, num2str(i), 'FontSize', 7, 'Color', 'k');
    end
    bDepot = min(inst.ps.depotBus, nb);
    hDepotBus = scatter(busXY(bDepot,1),busXY(bDepot,2),90,'kd','filled');
    hDepot = scatter(inst.depot(1),inst.depot(2),120,'ks','filled');
    C = inst.coords; hCust = scatter(C(:,1),C(:,2),55,'bo','filled');
    plot(meta.C1(:,1),meta.C1(:,2),':','Color',[0.6 0.6 0.6]);
    plot(meta.C2(:,1),meta.C2(:,2),':','Color',[0.6 0.6 0.6]);
    xlabel('km (x)'); ylabel('km (y)'); title('Distribution Grid vs. Depot and Customers');
    legend_items = [hBranches, hBuses, hDepotBus, hDepot, hCust];
    legend_labels = {'Active Feeders', 'Buses', 'Depot bus','Depot','Customers'};
    if ~isempty(hTieLines)
        legend_items = [hBranches, hTieLines, hBuses, hDepotBus, hDepot, hCust];
        legend_labels = {'Active Feeders','Open Tie-Lines', 'Buses', 'Depot bus','Depot','Customers'};
    end
    legend(legend_items, legend_labels, 'Location','bestoutside');
end
% --- CHANGE: This function now allows manual coordinate setting ---
function [busXY, meta, instOut] = buildTokyoRingLayout(nb, inst)
    ctr = inst.cityCenter(:)'; maxR = max(1, max(sqrt(sum((inst.coords - ctr).^2, 2))));
    r1 = 0.70*maxR; r2 = 1.05*maxR; ax1=1.00; ay1=0.85; ax2=1.10; ay2=0.95;
    ang = deg2rad(20); R = [cos(ang), -sin(ang); sin(ang), cos(ang)];
    depR = r2 + 2.0; dirNW = [-cos(pi/4), sin(pi/4)];
    instOut = inst; instOut.depot = ctr + depR*dirNW;
    busXY = zeros(nb,2);
    
    % Define the main loop buses and their sequence based on the 33bw diagram
    main_loop_sequence = [22, 21, 20, 19, 18, 1, 2, 3, 23, 24, 25, 29, 30, 31, 32, 17, 16, 15, 14, 13, 12];
    
    % Place main loop buses along the C2 arc
    num_loop = numel(main_loop_sequence);
    start_angle = 1.1*pi; end_angle = -0.4*pi;
    angles = linspace(start_angle, end_angle, num_loop);
    
    for i = 1:num_loop
        node_idx = main_loop_sequence(i);
        angle = angles(i);
        pos = [ax2*r2*cos(angle), ay2*r2*sin(angle)] * R' + ctr;
        busXY(node_idx, :) = pos;
    end
    
    % Place internal buses using a BFS approach
    G = digraph(inst.ps.L(:,1), inst.ps.L(:,2));
    nodes_to_process = main_loop_sequence;
    processed_nodes = zeros(1, nb);
    processed_nodes(main_loop_sequence) = 1;
    head = 1;
    
    while head <= numel(nodes_to_process)
        parent_node = nodes_to_process(head);
        head = head + 1;
        children = successors(G, parent_node);
        
        children = children(~processed_nodes(children));
        
        for i = 1:numel(children)
            child_node = children(i);
            parent_pos = busXY(parent_node,:);
            
            offset_angle = rand * pi/4 - pi/8; 
            offset_vec = [cos(offset_angle), sin(offset_angle)] * (0.15*r2);
            child_pos = parent_pos - offset_vec;
            
            busXY(child_node, :) = child_pos;
            processed_nodes(child_node) = 1;
            nodes_to_process(end+1) = child_node; %#ok<AGROW>
        end
    end

    % --- SECTION FOR MANUAL COORDINATE OVERRIDES ---
    % To manually set the position of specific buses, define their
    % coordinates here. The plot is centered at [0,0] and the C2
    % ring has a radius of approximately 12-15 units.
    manual_coords = containers.Map('KeyType','double','ValueType','any');
    manual_coords(4) = [-7, 9];   % Replace [0,0] with your desired [x,y]
    manual_coords(5) = [-3, 8];
    manual_coords(6) = [0, 6];
    manual_coords(7) = [1, 4];
    manual_coords(8) = [3, -3];
    manual_coords(9) = [4, -5];
    manual_coords(10) = [5, -7];
    manual_coords(11) = [8, -8];
    manual_coords(26) = [2, 8];
    manual_coords(27) = [5, 10];
    manual_coords(28) = [10, 11];
    manual_coords(18) = [17.724, 5.99893];
    manual_coords(33) = [17.0947, 7.57698];
    manual_coords(1) = [10, 11];
    
    for bus_idx = keys(manual_coords)
        busXY(bus_idx{1}, :) = manual_coords(bus_idx{1});
    end
    
    tt = linspace(0,2*pi,240)';
    meta.C1 = ([ax1*r1*cos(tt), ay1*r1*sin(tt)] * R') + ctr;
    meta.C2 = ([ax2*r2*cos(tt), ay2*r2*sin(tt)] * R') + ctr;
    meta.center = ctr; meta.r1 = r1; meta.r2 = r2; meta.R = R;
end
function plotIterationHistory(hist)
    % Corrected function definition
    if isempty(hist) || isempty(hist.obj), return; end
    figure('Name','Iteration History'); it=1:numel(hist.obj);
    subplot(2,3,1); plot(it,hist.obj,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Objective (Fitness)');
    subplot(2,3,2); plot(it,hist.peak,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Depot peak (kW)');
    subplot(2,3,3); plot(it,hist.energyKWh,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Depot energy (kWh)');
    subplot(2,3,4);
    if ~isempty(hist.Pdepot), area((0:numel(hist.Pdepot{end})-1)*0.5, hist.Pdepot{end},'FaceAlpha',0.4); end
    grid on; xlabel('Time (h)'); ylabel('P_{depot} (kW)'); title('Final Charging Profile');
    subplot(2,3,5); plot(it,hist.bonus,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Drone bonus');
end
function plotGanttIfAvailable(inst,sol)
    if isfield(sol,'launchTimes') && ~isempty([sol.launchTimes{:}])
        figure('Name','Launch/Recovery Timeline'); hold on; grid on;
        xlabel('Time (h)'); ylabel('Drone');
        for u=1:numel(sol.launchTimes)
            if isempty(sol.launchTimes{u}), continue; end
            for m=1:numel(sol.launchTimes{u})
                lt=sol.launchTimes{u}(m); rt=sol.recoverTimes{u}(m);
                rectangle('Position',[lt,u-0.4,rt-lt,0.8],'FaceColor',[0.2 0.6 0.9 0.6],'EdgeColor','none');
            end
        end
        title('Drone Sorties (Gantt Chart)'); ylim([0,inst.nDrones+1]);
    else, warning('Gantt chart not plotted: no launch/recovery data in solution.'); end
end
function saveFiguresAndData(inst,sol,hist,writeMD)
    ts=datestr(now,'yyyy-mm-dd_HHMMSS'); outDir=fullfile(pwd,['cpeee_outputs_GA_' ts]);
    if ~exist(outDir,'dir'), mkdir(outDir); end
    figs=findobj('Type','figure');
    for i = 1:numel(figs)
        f=figs(i); nm=get(f,'Name'); if isempty(nm), nm=sprintf('Figure_%d',i); end
        safe_nm = regexprep(nm, '[^a-zA-Z0-9_]', '_');
        exportgraphics(f, fullfile(outDir,[safe_nm '_' ts '.png']));
    end
    t=(0:inst.T-1)'*inst.dt;
    Ttbl=table(t,sol.Pdepot(:),inst.ps.tariff(:),'VariableNames',{'time_h','Pdepot_kW','tariff_usd_per_kWh'});
    writetable(Ttbl, fullfile(outDir,['charging_and_tariff_' ts '.csv']));
    if nargin>3 && writeMD && ~isempty(hist)
        H=table((1:numel(hist.obj))',hist.obj(:),hist.truck(:),zeros(numel(hist.obj),1),hist.energy(:),hist.bonus(:),hist.peak(:),hist.energyKWh(:), ...
        'VariableNames',{'iter','objective','truck','lateness','energy','drone_bonus','peak_kW','energy_kWh'});
        writetable(H, fullfile(outDir,['iteration_history_' ts '.csv']));
    end
    if nargin>3 && writeMD
        fid=fopen(fullfile(outDir,['README_' ts '.md']),'w');
        md={['# CPEEE exports ' ts],'## Figures','- Charging and Tariff','- Scenario map','- Grid layout (Tokyo rings)', ...
        '- Gantt (if available)','## Data',['- charging_and_tariff_' ts '.csv']};
        if ~isempty(hist), md{end+1} = ['- iteration_history_' ts '.csv']; end
        fprintf(fid,'%s\n',md{:}); fclose(fid);
    end
    fprintf('Saved all outputs to: %s\n', outDir);
end

