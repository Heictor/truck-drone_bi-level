% CPEEE 2026 — Energy-aware truck–drone logistics co-optimized with grid

% Final (Tokyo rings + tunables + exact no-go + initial energy + timing ON)

% - Tunables: main(nCust, nTrucks, nDrones)

% - Customers: uniform in [-12, 12]^2

% - Tokyo C1/C2 schematic layout

% - Depot northwest, outside C2

% - Truck no-go zone inside C1 (elliptical, rotated, matches plot)

% - Initial fleet SoC E0 and aggregate energy feasibility

% - Time precedence constraints are ON by default, with slack for feasibility

% - Safer truck-flow (≤ modality) to avoid depot-node subtour issues

% - MATPOWER OPF oracle per timestep; timestamped exports

function main(nCust, nTrucks, nDrones)

if nargin < 1, nCust   = 30; end

if nargin < 2, nTrucks = 3;  end

if nargin < 3, nDrones = 8;  end

close all; clc;

addpath(genpath(fullfile(pwd,'matpower8.1'))); % adjust if needed

inst = demoInstance(nCust, nTrucks, nDrones);

cuts = struct('A',{},'b',{});

maxIter=15; eps=1e-6; best=[]; objBest=inf; bestModel=[];

hist = struct('obj',[],'truck',[],'late',[],'energy',[], 'bonus',[], ...

'peak',[],'energyKWh',[],'Pdepot',{{}}, 'feasible',[],'viol',[]);

for it=1:maxIter

model = buildLogisticsMILP(inst, cuts);

opts = optimoptions('intlinprog','Display','off','Heuristics','advanced', ...
'LPPreprocess','advanced','CutGeneration','intermediate');

[xsol,fval,exitflag] = intlinprog(model.f, model.intcon, model.A, model.b, ...
model.Aeq, model.beq, [model.lb](http://model.lb), model.ub, opts);

assert(exitflag>0,'Master MILP infeasible or not solved (exitflag=%d).',exitflag);

sol = decodeSolution(inst, model, xsol);

sol = buildLaunchRecovery(inst, model, sol);

[feasible, viol, pattern] = gridCheckMatpower(inst, sol);

comps = objectiveBreakdown(inst, model, sol);

hist.obj(end+1)=fval; hist.truck(end+1)=comps.truck; hist.late(end+1)=comps.late;

hist.energy(end+1)=comps.energy; hist.bonus(end+1)=comps.droneBonus;

hist.peak(end+1)=max(sol.Pdepot); hist.energyKWh(end+1)=sum(sol.Pdepot)*inst.dt;

hist.Pdepot{end+1}=sol.Pdepot(:)'; hist.feasible(end+1)=feasible; hist.viol(end+1)=viol;

fprintf('Iter %d: obj=%.3f, feasible=%d, max viol=%.4fn', it, fval, feasible, viol);

if feasible

if fval+eps<objBest, best=sol; objBest=fval; bestModel=model; end

break;

else

cuts(end+1)=addGridCut(inst,pattern); %#ok<AGROW>

end

end

if isempty(best), best=sol; objBest=fval; bestModel=model; end

fprintf('Best objective: %.3fn', objBest);

comps = objectiveBreakdown(inst, bestModel, best);

fprintf('Objective breakdown => Truck: %.3f, Lateness: %.3f, Energy: %.3f, DroneBonus: %.3f, Total(est): %.3fn', ...

comps.truck, comps.late, comps.energy, comps.droneBonus, ...

comps.truck+comps.late+comps.energy+comps.droneBonus);

reportSolution(inst, best);

plotChargingAndTariff(inst, best);

plotScenario(inst, best);

plotGridWithScenario(inst, best);

plotIterationHistory(inst, hist);

plotGanttIfAvailable(inst, best);

saveFiguresAndData(inst, best, hist, true);

end

% ========= Instance (tunables + random customers + Tokyo rings aux) =========

function inst = demoInstance(nCust, nTrucks, nDrones)

inst.nCust   = nCust;

inst.nTrucks = nTrucks;

inst.nDrones = nDrones;

inst.T  = 24;

inst.dt = 0.5;

[inst.coords, inst.W, [inst.tw](http://inst.tw)] = tinyCustomers(inst.nCust);

inst.cityCenter = [0, 0];         % reference center for rings

inst.depot      = [-14, 10];      % initial; finalized in buildTokyoRingLayout

inst.vTruck = 30; inst.vDrone = 50; inst.serv = 0.05; inst.sortieFlightTime = 0.20;

% Time precedence ON by default, with slack for feasibility

inst.enableTimePrecedence = true;

inst.enableTimingSlack    = true;

ps = tinyFeeder33(); ps.depotBus = 5;

ps.tariff = 0.4 + 0.2*(sin((1:inst.T)/inst.T*2*pi - pi/2) > 0);

ps.PcapDepot = 3.0*ones(1,inst.T);

ps.mpccase = @case33bw;

[inst.ps](http://inst.ps) = ps;

inst.droneCapWh = 0.35*1000;

inst.etaCharge  = 0.92;

inst.cWh_per_km = @(w) 20 + 8*w;

inst.alphaDelay = 100;

inst.cTruckKm   = 1.2;

inst.droneIncentive = -0.05;  % mild incentive to use drones

end

function [coords, W, tw] = tinyCustomers(n)

rng('shuffle');

coords = -12 + 24*rand(n,2);      % uniform in [-12,12]^2

W  = 0.5 + 0.5*rand(n,1);

tw = [1.0*ones(n,1), 6.0*ones(n,1)];

end

function ps = tinyFeeder33()

nb=33; ps.nb=nb;

parent=[1 1 2 2 3 3 4 5 6 7 7 8 9 9 10 12 13 14 15 15 16 18 19 20 20 21 22 23 23 24 25 26];

child =[2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 19 20 21 22 23 24 25 26 27 28 29];

ps.L=[parent(:),child(:)];

m=size(ps.L,1);

ps.R=0.05*ones(m,1); ps.X=0.04*ones(m,1);

ps.Imax=200*ones(m,1); ps.Smax=1000*ones(nb,1);

ps.baseLoad=5+3*rand(nb,1);

end

% ========= MILP (route-time + SoC + exact truck no-go inside C1) =========

function model=buildLogisticsMILP(inst,cuts)

n=inst.nCust; T=inst.T; dt=inst.dt; depot=inst.depot; C=inst.coords;

d = pdist2([depot;C],[depot;C],'euclidean');

distDepot = d(2:end,1);

% Drone sortie energy (kWh): round-trip depot<->cust distance * Wh/km

airDist  = 2*sqrt(sum((C - depot).^2,2)); % km round trip

e_sortie = (inst.cWh_per_km(mean(inst.W))/1000) * airDist; % kWh per customer

% Exact C1 ellipse (match plot): center, radii, rotation

ctr = inst.cityCenter(:)';

maxR = max(1, max(sqrt(sum((inst.coords - ctr).^2, 2))));

r1 = 0.70*maxR;      % C1 scaling

ax1 = 1.00; ay1 = 0.85;

ang = deg2rad(20);

Rrot = [cos(ang), -sin(ang); sin(ang), cos(ang)];

X = (inst.coords - ctr) * Rrot;  % rotate into ring frame

insideC1 = (X(:,1)./(ax1*r1)).^2 + (X(:,2)./(ay1*r1)).^2 <= 1 + 1e-9;

% Indices

ix.x=reshape(1:n*n,n,n); base=n*n;

ix.arr=base+(1:n)';      base=base+n;

ix.m=base+(1:n)';        base=base+n;

ix.p=base+(1:T)';        base=base+T;

ix.E=base+(1:T)';        base=base+T;

ix.z=base+(1:n)';        base=base+n;

% Optional timing slack (one per customer)

if inst.enableTimePrecedence && isfield(inst,'enableTimingSlack') && inst.enableTimingSlack

ix.u = base + (1:n)';  base = base + n;

else

ix.u = [];

end

N=base;

intcon=unique(double([ix.m(:); ix.z(:); find(ix.x(:))]));

% Objective

f=zeros(N,1);

truckArcCost = 0.5*inst.cTruckKm*  d(2:end,2:end); f(ix.x(:)) = truckArcCost(:);

f(ix.p)=[inst.ps](http://inst.ps).tariff(:)';

f(ix.m)=f(ix.m)+0.05+inst.cTruckKm*distDepot; % per-customer truck penalty+proxy

f(ix.z)=f(ix.z)+inst.droneIncentive;          % drone incentive (can be <0)

if ~isempty(ix.u)

f(ix.u) = 10;  % penalty per hour of timing violation (tune)

end

% Bounds

lb=zeros(N,1); ub=inf(N,1);

ub(ix.x(:))=1; ub(ix.m)=1; ub(ix.z)=1; ub(ix.p)=[inst.ps](http://inst.ps).PcapDepot(:);

lb(ix.arr)=[inst.tw](http://inst.tw)(:,1); ub(ix.arr)=[inst.tw](http://inst.tw)(:,2);

% Fleet energy bounds and initial E0

CapKWh=inst.nDrones*inst.droneCapWh/1000; lb(ix.E)=0; ub(ix.E)=CapKWh;

E0 = CapKWh; % start full (change to 0.8*CapKWh if you prefer 80%)

% Anchor initial fleet SoC

Aeq=[]; beq=[];

Aeq = [Aeq; zeros(1,N)]; Aeq(end, ix.E(1)) = 1; beq = [beq; E0];

% Forbid self-loops

for i=1:n, ub(ix.x(i,i))=0; end

% Truck forbidden inside C1: enforce m(i)=0, z(i)=1

for i = 1:n

if insideC1(i)

ub(ix.m(i)) = 0;  % m(i) = 0

lb(ix.z(i)) = 1;  % z(i) = 1

end

end

% Constraints

A=[]; b=[];

% Truck flow conservation (≤ modality). Safer without depot nodes.

for j=1:n

a=zeros(1,N); a(ix.x(:,j))=1; a(ix.m(j))=-1; A = [A; a]; b = [b; 0]; % in-degree ≤ m(j)

a=zeros(1,N); a(ix.x(j,:))=1; a(ix.m(j))=-1; A = [A; a]; b = [b; 0]; % out-degree ≤ m(j)

end

% Exactly once: truck or drone

Aeq = [Aeq; zeros(n,N)]; beq = [beq; ones(n,1)];

for i=1:n, Aeq(end-n+i, ix.m(i)) = 1; Aeq(end-n+i, ix.z(i)) = 1; end

% Time precedence (big-M) — only if enabled

% Safe big-M from windows + worst travel

TWspan  = max([inst.tw](http://inst.tw)(:,2) - [inst.tw](http://inst.tw)(:,1));

maxTij  = max(d(2:end,2:end),[],'all')/inst.vTruck;

M = TWspan + maxTij + inst.serv + 5;

if inst.enableTimePrecedence

for i=1:n

for j=1:n

if i==j, continue; end

tij=d(i+1,j+1)/inst.vTruck;

a=zeros(1,N); a(ix.arr(j))=1; a(ix.arr(i))=-1; a(ix.x(i,j))=-M;

if ~isempty(ix.u), a(ix.u(j)) = -1; end

A=[A; a]; b=[b; -(inst.serv + tij - M)];

end

end

end

% Charger capacity each step

for k=1:T, a=zeros(1,N); a(ix.p(k))=1; A=[A; a]; b=[b; [inst.ps](http://inst.ps).PcapDepot(k)]; end

% Fleet SoC proxy dynamics (E_{k+1} - E_k - η p_k Δt ≤ 0)

for k=1:T-1

a=zeros(1,N); a(ix.E(k+1))=1; a(ix.E(k))=-1; a(ix.p(k))=-inst.etaCharge*dt;

A=[A; a]; b=[b; 0];

end

% Aggregate energy feasibility for sorties: ∑ e_i z_i - η ∑ p_k Δt ≤ E0

a=zeros(1,N); a(ix.z) = e_sortie(:)'; a(ix.p) = a(ix.p) - inst.etaCharge*dt;

A=[A; a]; b=[b; E0];

% Feasibility cuts on Pdepot

for c=1:numel(cuts)

a=zeros(1,N); a(ix.p)=cuts(c).A(:)'; A=[A; a]; b=[b; cuts(c).b];

end

model=struct('f',f,'intcon',intcon,'A',A,'b',b,'Aeq',Aeq,'beq',beq,'lb',lb,'ub',ub, ...

'meta',struct('ix',ix,'distDepot',distDepot,'e_sortie',e_sortie));

end

function sol=decodeSolution(inst,model,x)

ix=model.meta.ix;

sol.xArc=round(reshape(x(ix.x(:)),size(ix.x)));

sol.mTruck=round(x(ix.m)); sol.zDrone=round(x(ix.z));

sol.arr=x(ix.arr); sol.Pdepot=x(ix.p); sol.Efleet=x(ix.E);

sol.truckCust=find(sol.mTruck==1); sol.droneCust=find(sol.zDrone==1);

end

function sol=buildLaunchRecovery(inst,~,sol)

U=inst.nDrones; sol.launchTimes=cell(U,1); sol.recoverTimes=cell(U,1);

if isempty(sol.droneCust), return; end

mid=mean([inst.tw](http://inst.tw),2); lst=sol.droneCust(:)';

for idx=1:numel(lst)

u=mod(idx-1,U)+1; i=lst(idx);

t0=max([inst.tw](http://inst.tw)(i,1), mid(i)-inst.sortieFlightTime/2);

t1=min([inst.tw](http://inst.tw)(i,2), t0+inst.sortieFlightTime);

sol.launchTimes{u}(end+1)=t0; sol.recoverTimes{u}(end+1)=t1;

end

end

% ========= OPF oracle =========

function [feasible,maxViol,pattern]=gridCheckMatpower(inst,sol)

if exist('startup.m','file'), try, run('startup.m'); end, end

T=inst.T; bDepot=[inst.ps](http://inst.ps).depotBus; feasible=true; maxViol=0; pattern=zeros(1,T);

for k=1:T

if isa([inst.ps](http://inst.ps).mpccase,'function_handle'), mpc=feval([inst.ps](http://inst.ps).mpccase); else, mpc=case33bw; end

Pd_add=sol.Pdepot(k)/1000; bIdx=min(bDepot,size(mpc.bus,1));

mpc.bus(bIdx,3)=mpc.bus(bIdx,3)+Pd_add;

try

r=runopf(mpc, mpoption('verbose',0,'out.all',0));

ok=isfield(r,'success')&&r.success==1; if ~ok, feasible=false; maxViol=max(maxViol,1); pattern(k)=1; continue; end

if isfield(r,'branch')&&size(r.branch,2)>=15

S=hypot(r.branch(:,14),r.branch(:,15)); rate=max(1e-6,r.branch(:,6)); viol=max(0,max(S-rate));

else, viol=0; end

if viol>1e-6, feasible=false; pattern(k)=1; end; maxViol=max(maxViol,viol);

catch

feasible=false; pattern(k)=1; maxViol=max(maxViol,1);

end

end

end

function cut=addGridCut(inst,pattern), cut.A=pattern(:)'; cut.b=0.9*sum([inst.ps](http://inst.ps).PcapDepot(~pattern)); end

% ========= Reporting / plots =========

function comps=objectiveBreakdown(inst,model,sol)

truckCost=inst.cTruckKm*sum(model.meta.distDepot(:)'.*(sol.mTruck(:)'));

lateCost=0; energyCost=sum(sol.Pdepot(:)'.[*inst.ps](http://inst.ps).tariff(:)')*inst.dt;

droneBonus=inst.droneIncentive*sum(sol.zDrone);

comps=struct('truck',truckCost,'late',lateCost,'energy',energyCost,'droneBonus',droneBonus);

end

function reportSolution(inst,sol)

fprintf('Truck-served customers: %sn',mat2str(find(sol.mTruck==1)));

fprintf('Drone-served customers: %sn',mat2str(find(sol.zDrone==1)));

fprintf('Depot peak (kW): %.2fn',max(sol.Pdepot));

fprintf('Depot energy (kWh): %.2fn',sum(sol.Pdepot)*inst.dt);

end

function plotChargingAndTariff(inst,sol)

T=inst.T; t=(0:T-1)*inst.dt; figure('Name','Charging and Tariff');

yyaxis left; stairs(t,sol.Pdepot,'LineWidth',2); hold on; stairs(t,[inst.ps](http://inst.ps).PcapDepot,'--','LineWidth',1.2);

ylabel('Depot charging (kW)'); ylim([0,max([inst.ps](http://inst.ps).PcapDepot)*1.2]);

yyaxis right; plot(t,[inst.ps](http://inst.ps).tariff,'Color',[0.85 0.33 0.1],'LineWidth',1.8);

ylabel('Tariff ($/kWh)'); grid on; xlabel('Time (h)');

title('Depot charging vs tariff and capacity'); legend('P_{depot}','Capacity','Tariff');

end

function plotScenario(inst,sol)

figure('Name','Scenario');

scatter(inst.depot(1),inst.depot(2),120,'ks','filled'); hold on;

C=inst.coords; idT=find(sol.mTruck==1); idD=find(sol.zDrone==1);

% Exact C1 test for plotting (matches MILP no-go)

ctr = inst.cityCenter(:)';

maxR = max(1, max(sqrt(sum((C - ctr).^2, 2))));

r1 = 0.70*maxR; ax1 = 1.00; ay1 = 0.85; ang = deg2rad(20);

Rrot = [cos(ang), -sin(ang); sin(ang), cos(ang)];

Xplot = (C - ctr) * Rrot;

insideC1_plot = (Xplot(:,1)./(ax1*r1)).^2 + (Xplot(:,2)./(ay1*r1)).^2 <= 1 + 1e-9;

scatter(C(idD,1),C(idD,2),60,'b','filled');

scatter(C(idT,1),C(idT,2),60,'r','filled');

% Drone lines to all drone-served customers

for i=idD(:)'

plot([inst.depot(1),C(i,1)],[inst.depot(2),C(i,2)],'b-');

end

% Truck lines only to truck-served customers that are NOT inside C1

for i=idT(:)'

if ~insideC1_plot(i)

plot([inst.depot(1),C(i,1)],[inst.depot(2),C(i,2)],'r-');

end

end

legend('Depot','Drone customers','Truck customers','Location','bestoutside');

axis equal; grid on; xlabel('km (x)'); ylabel('km (y)');

title('Illustrative logistics scenario (assignments) with C1 no-go for trucks');

end

function plotGridWithScenario(inst, sol)

nb = [inst.ps](http://inst.ps).nb; if isempty(nb), nb = max([inst.ps](http://inst.ps).L(:)); end

[busXY, meta, inst2] = buildTokyoRingLayout(nb, inst); % updates depot NW

inst.depot = inst2.depot; % keep for drawing

figure('Name','Grid layout (Tokyo rings) with depot and customers');

hold on; grid on; axis equal;

hBranches = [];

for e = 1:size([inst.ps](http://inst.ps).L,1)

i = [inst.ps](http://inst.ps).L(e,1); j = [inst.ps](http://inst.ps).L(e,2);

if i<=nb && j<=nb

h = plot([busXY(i,1), busXY(j,1)], [busXY(i,2), busXY(j,2)], '-', ...

'Color', [0.55 0.55 0.55], 'LineWidth', 1.1);

if isempty(hBranches), hBranches = h; end

end

end

bDepot = min([inst.ps](http://inst.ps).depotBus, nb);

hDepotBus = scatter(busXY(bDepot,1), busXY(bDepot,2), 90, 'kd', 'filled');

hDepot = scatter(inst.depot(1), inst.depot(2), 120, 'ks', 'filled');

C = inst.coords; hCust  = scatter(C(:,1), C(:,2), 55, 'bo', 'filled');

plot(meta.C1(:,1), meta.C1(:,2), ':', 'Color', [0.6 0.6 0.6]);

plot(meta.C2(:,1), meta.C2(:,2), ':', 'Color', [0.6 0.6 0.6]);

xlabel('km (x)'); ylabel('km (y)');

title('Distribution grid vs. depot and customers (Tokyo C1/C2 schematic)');

legend([hBranches, hDepotBus, hDepot, hCust], ...

{'Feeder branches','Depot bus','Depot','Customers'}, ...

'Location','bestoutside');

end

function [busXY, meta, instOut] = buildTokyoRingLayout(nb, inst)

ctr = inst.cityCenter(:)';

% Ring sizes from customer spread

maxR = max(1, max(sqrt(sum((inst.coords - ctr).^2, 2))));

r1 = 0.70*maxR;   % C1

r2 = 1.05*maxR;   % C2

% Ellipse and rotation

ax1 = 1.00; ay1 = 0.85; ax2 = 1.10; ay2 = 0.95;

ang = deg2rad(20); R = [cos(ang), -sin(ang); sin(ang), cos(ang)];

% Sample rings

n1 = ceil(nb/2); n2 = nb - n1;

t1 = linspace(0, 2*pi, max(16, n1+2)); t1(end) = [];

t2 = linspace(0, 2*pi, max(16, n2+2)); t2(end) = [];

C1 = ([ax1*r1*cos(t1)', ay1*r1*sin(t1)'] * R') + ctr;

C2 = ([ax2*r2*cos(t2)', ay2*r2*sin(t2)'] * R') + ctr;

% Final depot northwest and outside C2

depR = r2 + 2.0; dirNW = [-cos(pi/4), sin(pi/4)];

instOut = inst; instOut.depot = ctr + depR*dirNW;

% Bus placement

busXY = zeros(nb,2);

busXY(1:n1,:)        = C1(round(linspace(1,size(C1,1),n1)), :);

busXY(n1+1:nb,:)     = C2(round(linspace(1,size(C2,1),n2)), :);

% Spokes

spokeCount = min(4, n2);

if spokeCount > 0

pick = n1 + unique(round(linspace(1, n2, spokeCount)));

for k = pick(:)'

alpha = 0.3 + 0.15*rand; busXY(k,:) = (1-alpha)*busXY(k,:) + alpha*ctr;

end

end

% Guides

tt = linspace(0,2*pi,240)';

meta.C1 = ([ax1*r1*cos(tt), ay1*r1*sin(tt)] * R') + ctr;

meta.C2 = ([ax2*r2*cos(tt), ay2*r2*sin(tt)] * R') + ctr;

[meta.center](http://meta.center) = ctr; meta.r1 = r1; meta.r2 = r2; meta.R = R;

end

function plotIterationHistory(inst,hist)

it=1:numel(hist.obj); figure('Name','Iteration history');

subplot(2,3,1); plot(it,hist.obj,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Objective');

subplot(2,3,2); plot(it,hist.peak,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Depot peak (kW)');

subplot(2,3,3); plot(it,hist.energyKWh,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Depot energy (kWh)');

subplot(2,3,4); if ~isempty(hist.Pdepot), area((0:inst.T-1)*inst.dt, cell2mat(hist.Pdepot(end)),'FaceAlpha',0.4); end

grid on; xlabel('Time (h)'); ylabel('P_{depot} (kW)'); title('Final charging');

subplot(2,3,5); plot(it, hist.bonus,'-o','LineWidth',1.6); grid on; xlabel('Iter'); ylabel('Drone bonus');

end

function plotGanttIfAvailable(inst,sol)

if isfield(sol,'launchTimes') && isfield(sol,'recoverTimes') && ~isempty([sol.launchTimes{:}])

figure('Name','Launch/Recovery timeline'); hold on; grid on; xlabel('Time (h)'); ylabel('Drone');

for u=1:numel(sol.launchTimes)

if isempty(sol.launchTimes{u}), continue; end

for m=1:numel(sol.launchTimes{u})

lt=sol.launchTimes{u}(m); rt=sol.recoverTimes{u}(m);

rectangle('Position',[lt,u-0.4,rt-lt,0.8],'FaceColor',[0.2 0.6 0.9 0.6],'EdgeColor','none');

end

end

title('Drone sorties (Gantt)'); ylim([0,inst.nDrones+1]);

else, warning('Gantt not plotted: no launch/recovery data.'); end

end

function saveFiguresAndData(inst,sol,hist,writeMD)

ts=datestr(now,'yyyy-mm-dd_HHMMSS'); outDir=fullfile(pwd,['cpeee_outputs_' ts]);

if ~exist(outDir,'dir'), mkdir(outDir); end

figs=findobj('Type','figure'); for i=1:numel(figs)

f=figs(i); nm=get(f,'Name'); if isempty(nm), nm=sprintf('Figure_%d',i); end

exportgraphics(f, fullfile(outDir,[regexprep(nm,'[[1]](a-zA-Z0-9_)','*') '*' ts '.png']));

end

t=(0:inst.T-1)'*inst.dt;

Ttbl=table(t,sol.Pdepot(:),[inst.ps](http://inst.ps).tariff(:),'VariableNames',{'time_h','Pdepot_kW','tariff_usd_per_kWh'});

writetable(Ttbl, fullfile(outDir,['charging_and_tariff_' ts '.csv']));

H=table((1:numel(hist.obj))',hist.obj(:),hist.truck(:),hist.late(:),hist.energy(:),hist.bonus(:),hist.peak(:),hist.energyKWh(:), ...

'VariableNames',{'iter','objective','truck','lateness','energy','drone_bonus','peak_kW','energy_kWh'});

writetable(H, fullfile(outDir,['iteration_history_' ts '.csv']));

if nargin>3 && writeMD

fid=fopen(fullfile(outDir,['README_' ts '.md']),'w');

md={['# CPEEE exports ' ts],'## Figures','- Charging and Tariff','- Scenario map','- Grid layout (Tokyo rings)', ...

'- Iteration history','- Gantt (if available)','## Data',['- charging_and_tariff_' ts '.csv'],['- iteration_history_' ts '.csv']};

fprintf(fid,'%sn',md{:}); fclose(fid);

end

fprintf('Saved outputs to: %sn', outDir);

end