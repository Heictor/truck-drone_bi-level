function [final_total_cost, computation_time_sec] = runSingleSimulation(sim_params)
% =========================================================================
% MODULAR SIMULATION FOR BI-LEVEL TRUCK-DRONE OPTIMIZATION
%
% VERSION: 12.0 (Final Plotting Enhancements)
% CHANGES:
%   - Standardized font size to 12 and DPI to 600 for all plots.
%   - All plots are now saved as both .png and .fig files.
%   - All legends are set to 'bestoutside' for clarity.
%
% Author: Heictor Costa
% Date:   October 01, 2025
% =========================================================================
computation_timer = tic;
rng_state_on_start = rng;
rng(sim_params.rng_seed);
try
% =========================================================================
% SECTION 1 & 2: PARAMETERS AND ENVIRONMENT SETUP
% =========================================================================
floorSizeX = 5; floorSizeY = 5; gridResolution = 0.1; gridSizeX_drone = floor(floorSizeX / gridResolution); gridSizeY_drone = floor(floorSizeY / gridResolution); xOffset_drone = floorSizeX / 2; yOffset_drone = floorSizeY / 2; worldSizeX = 12; worldSizeY = 12; gridSizeX_truck = floor(worldSizeX / gridResolution); gridSizeY_truck = floor(worldSizeY / gridResolution); xOffset_truck = worldSizeX / 2; yOffset_truck = worldSizeY / 2;
numTargets = sim_params.numTargets; numObstacles = sim_params.numObstacles; maxPackageWeight = sim_params.maxPackageWeight;
numTrucks = numTargets; numNodes = 10; numParkingSpots = numTrucks; truckSpeed = 36.0; truckDiagFlightEnabled = false;
droneSpeed_H_base = 25.0; droneSpeed_V_base = 10.0; payloadSpeedFactor = 0.4; droneCruiseAltitude = 0.120; droneStayTime = 5 / 3600; droneBatteryMin = 0.1; initialBattery = 1.0; droneDiagFlightEnabled = true; droneSafetyRadius = 0.005;
cost = struct(); cost.truckPerKm=1.50; cost.truckPerHour=25.00; cost.dronePerHour=20.00; cost.obstaclePenalty=1000.00; cost.batteryPenalty=0.10; cost.signalPenalty=500.00;
ga.populationSize=50; ga.maxGenerations=20; ga.mutationRate=0.1; aco.numAnts=30; aco.maxGenerations=20; aco.pheromone_evaporation=0.4; aco.pheromone_deposit_factor=100; aco.alpha=1; aco.beta=2; alns.maxIterations=200; alns.reward1=5; alns.reward2=3; alns.reward3=1; alns.reaction=0.1; alns.startTemp=100; alns.coolingRate=0.995;
boa.populationSize=20; boa.maxGenerations=20; boa.fmin=0; boa.fmax=2; boa.loudness=0.5; boa.pulseRate=0.5; pso.populationSize=20; pso.maxGenerations=20; pso.inertia=0.7; pso.cognition=1.5; pso.social=1.5; bso.populationSize=20; bso.maxGenerations=20; bso.numClusters=4; bso.p_one_cluster=0.2; bso.p_one_center=0.4; bso.p_two_centers=0.5; cmaes.populationSize=10; cmaes.maxGenerations=20; cmaes.sigma=0.5;
R1=8; R2=10; k1=0.1; k2=100;
targetPositions = zeros(numTargets, 2); for i=1:numTargets, targetPositions(i, 1)=(rand()*floorSizeX)+(xOffset_truck-xOffset_drone); targetPositions(i, 2)=(rand()*floorSizeY)+(yOffset_truck-yOffset_drone); end
targetPositions_local = targetPositions-[xOffset_truck-xOffset_drone, yOffset_truck-yOffset_drone]; target_indices_local = floor(targetPositions_local/gridResolution)+1;
gridMap_drone = false(gridSizeY_drone, gridSizeX_drone); obstacles = struct('x',{},'y',{},'w',{},'h',{},'z',{}); safetyRadius_cells = ceil(droneSafetyRadius/gridResolution);
for i=1:numObstacles, isPlacementValid=false; while ~isPlacementValid, obsW_km=0.1+rand()*0.3; obsH_km=0.1+rand()*0.3; obsW=floor(obsW_km/gridResolution); obsH=floor(obsH_km/gridResolution); obsX=randi(gridSizeX_drone-obsW); obsY=randi(gridSizeY_drone-obsH); isClearOfTargets=true; expanded_x_min=obsX-safetyRadius_cells; expanded_x_max=obsX+obsW-1+safetyRadius_cells; expanded_y_min=obsY-safetyRadius_cells; expanded_y_max=obsY+obsH-1+safetyRadius_cells; for j=1:numTargets, tx=target_indices_local(j,1); ty=target_indices_local(j,2); if (tx>=expanded_x_min && tx<=expanded_x_max && ty>=expanded_y_min && ty<=expanded_y_max), isClearOfTargets=false; break; end; end; if isClearOfTargets, isPlacementValid=true; obsZ=(0.024+rand()*0.084); gridMap_drone(obsY:obsY+obsH-1, obsX:obsX+obsW-1)=true; obstacles(end+1)=struct('x',obsX,'y',obsY,'w',obsW,'h',obsH,'z',obsZ); end; end; end
inflatedMap_drone = gridMap_drone; [obs_y, obs_x] = find(gridMap_drone); for i=1:length(obs_x), for dy=-safetyRadius_cells:safetyRadius_cells, for dx=-safetyRadius_cells:safetyRadius_cells, if sqrt(dx^2+dy^2)<=safetyRadius_cells, ny=obs_y(i)+dy; nx=obs_x(i)+dx; if ny>0 && ny<=gridSizeY_drone && nx>0 && nx<=gridSizeX_drone, inflatedMap_drone(ny, nx)=true; end; end; end; end; end
truckGridMap=false(gridSizeY_truck, gridSizeX_truck); noGo_x_start=(xOffset_truck-floorSizeX/2); noGo_y_start=(yOffset_truck-floorSizeY/2); noGo_x_start_idx=floor(noGo_x_start/gridResolution)+1; noGo_x_end_idx=floor((xOffset_truck+floorSizeX/2)/gridResolution)+1; noGo_y_start_idx=floor(noGo_y_start/gridResolution)+1; noGo_y_end_idx=floor((yOffset_truck+floorSizeY/2)/gridResolution)+1; truckGridMap(noGo_y_start_idx:noGo_y_end_idx, noGo_x_start_idx:noGo_x_end_idx)=true;
centralPoint=[xOffset_truck, yOffset_truck]; nodeRadius=4.0; truckNetworkNodes=zeros(numNodes,2); for i=1:numNodes, angle=2*pi*i/numNodes; truckNetworkNodes(i,:)=centralPoint+nodeRadius*[cos(angle),sin(angle)]; end; depotLocation=[xOffset_truck, yOffset_truck+5.0];

% =========================================================================
% SECTION 3: LOWER-LEVEL OPTIMIZATION
% =========================================================================
bestOverallCost = inf; bestSelectedSpots = []; bestCostHistory = []; avgCostHistory = [];
switch sim_params.lower_level_algo
    case 'GA', bestCostHistory = zeros(ga.maxGenerations, 1); avgCostHistory = zeros(ga.maxGenerations, 1); population = zeros(ga.populationSize, numNodes); for p = 1:ga.populationSize, population(p, :) = randperm(numNodes); end; for gen = 1:ga.maxGenerations, costMatrix = zeros(numTrucks, ga.populationSize); parfor p = 1:ga.populationSize, currentRouteIndices = population(p, :); selectedParkingNodeIndices = currentRouteIndices(1:numTrucks); costMatrix(:, p) = calculate_truck_fleet_cost(selectedParkingNodeIndices, truckNetworkNodes, targetPositions, truckGridMap, depotLocation, truckDiagFlightEnabled, worldSizeX, worldSizeY, truckSpeed, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H_base, droneSpeed_V_base, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY, xOffset_truck, yOffset_truck, maxPackageWeight, payloadSpeedFactor, sim_params.upper_level_algo, boa, pso, bso, cmaes); end; totalCosts = sum(costMatrix, 1); bestCostHistory(gen) = min(totalCosts); avgCostHistory(gen) = mean(totalCosts); [minGenCost, bestIdx] = min(totalCosts); if minGenCost < bestOverallCost, bestOverallCost = minGenCost; bestRouteIndices = population(bestIdx, :); bestSelectedSpots = truckNetworkNodes(bestRouteIndices(1:numTrucks), :); end; [~, sortedIndices] = sort(totalCosts); newPopulation = population(sortedIndices(1:ga.populationSize/2), :); for i = 1:(ga.populationSize/2), parent1_idx = randi(ga.populationSize/2); parent2_idx = randi(ga.populationSize/2); parent1 = newPopulation(parent1_idx, :); parent2 = newPopulation(parent2_idx, :); crossoverPoint = randi(numNodes - 1); child = [parent1(1:crossoverPoint), setdiff(parent2, parent1(1:crossoverPoint), 'stable')]; if rand < ga.mutationRate, mutationPoints = randperm(numNodes, 2); child([mutationPoints(1), mutationPoints(2)]) = child([mutationPoints(2), mutationPoints(1)]); end; newPopulation(i + ga.populationSize/2, :) = child; end; population = newPopulation; end
    case 'ACO', bestCostHistory = zeros(aco.maxGenerations, 1); avgCostHistory = zeros(aco.maxGenerations, 1); pheromone_trails = ones(numNodes, numNodes); for gen = 1:aco.maxGenerations, ant_solutions = cell(aco.numAnts, 1); ant_costs = zeros(numTrucks, aco.numAnts); parfor a = 1:aco.numAnts, available_nodes = 1:numNodes; current_solution = zeros(1, numNodes); for n_idx = 1:numNodes, probabilities = zeros(1, length(available_nodes)); for k = 1:length(available_nodes), node_k = available_nodes(k); heuristic_info = 1 / norm(truckNetworkNodes(node_k,:) - depotLocation); last_node = 1; if n_idx > 1, last_node = current_solution(n_idx-1); end; probabilities(k) = (pheromone_trails(last_node, node_k)^aco.alpha) * (heuristic_info^aco.beta); end; probabilities = probabilities / sum(probabilities); selected_node_idx = find(rand <= cumsum(probabilities), 1, 'first'); selected_node = available_nodes(selected_node_idx); current_solution(n_idx) = selected_node; available_nodes(selected_node_idx) = []; end; ant_solutions{a} = current_solution; selectedParkingNodeIndices = current_solution(1:numTrucks); ant_costs(:, a) = calculate_truck_fleet_cost(selectedParkingNodeIndices, truckNetworkNodes, targetPositions, truckGridMap, depotLocation, truckDiagFlightEnabled, worldSizeX, worldSizeY, truckSpeed, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H_base, droneSpeed_V_base, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY, xOffset_truck, yOffset_truck, maxPackageWeight, payloadSpeedFactor, sim_params.upper_level_algo, boa, pso, bso, cmaes); end; total_costs = sum(ant_costs, 1); bestCostHistory(gen) = min(total_costs); avgCostHistory(gen) = mean(total_costs); [minGenCost, best_ant_idx] = min(total_costs); if minGenCost < bestOverallCost, bestOverallCost = minGenCost; bestRouteIndices = ant_solutions{best_ant_idx}; bestSelectedSpots = truckNetworkNodes(bestRouteIndices(1:numTrucks), :); end; pheromone_trails = (1 - aco.pheromone_evaporation) * pheromone_trails; best_solution_path = ant_solutions{best_ant_idx}; for i = 1:length(best_solution_path)-1, node1 = best_solution_path(i); node2 = best_solution_path(i+1); pheromone_trails(node1, node2) = pheromone_trails(node1, node2) + aco.pheromone_deposit_factor / bestOverallCost; pheromone_trails(node2, node1) = pheromone_trails(node1, node2); end; end
    case 'ALNS', destroy_operators = {@destroy_random, @destroy_worst}; repair_operators = {@repair_greedy, @repair_random}; weights = ones(length(destroy_operators), length(repair_operators)); scores = zeros(size(weights)); current_solution_indices = randperm(numNodes); current_solution_indices = current_solution_indices(1:numParkingSpots); current_cost = sum(calculate_truck_fleet_cost(current_solution_indices, truckNetworkNodes, targetPositions, truckGridMap, depotLocation, truckDiagFlightEnabled, worldSizeX, worldSizeY, truckSpeed, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H_base, droneSpeed_V_base, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY, xOffset_truck, yOffset_truck, maxPackageWeight, payloadSpeedFactor, sim_params.upper_level_algo, boa, pso, bso, cmaes)); bestOverallCost = current_cost; bestSelectedSpots = truckNetworkNodes(current_solution_indices,:); bestCostHistory = zeros(alns.maxIterations, 1); temp = alns.startTemp; for iter = 1:alns.maxIterations, d_idx = roulette_wheel_selection(sum(weights, 2)); r_idx = roulette_wheel_selection(weights(d_idx, :)); destroy_op = destroy_operators{d_idx}; repair_op = repair_operators{r_idx}; q = randi([2, floor(numParkingSpots/2)]); [partial_solution, ~] = destroy_op(current_solution_indices, q, truckNetworkNodes); new_solution_indices = repair_op(partial_solution, numNodes, truckNetworkNodes); new_cost = sum(calculate_truck_fleet_cost(new_solution_indices, truckNetworkNodes, targetPositions, truckGridMap, depotLocation, truckDiagFlightEnabled, worldSizeX, worldSizeY, truckSpeed, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H_base, droneSpeed_V_base, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY, xOffset_truck, yOffset_truck, maxPackageWeight, payloadSpeedFactor, sim_params.upper_level_algo, boa, pso, bso, cmaes)); if new_cost < current_cost || rand() < exp((current_cost - new_cost) / temp), current_solution_indices = new_solution_indices; current_cost = new_cost; if new_cost < bestOverallCost, scores(d_idx, r_idx) = scores(d_idx, r_idx) + alns.reward1; bestOverallCost = new_cost; bestSelectedSpots = truckNetworkNodes(new_solution_indices, :); elseif new_cost < current_cost, scores(d_idx, r_idx) = scores(d_idx, r_idx) + alns.reward2; else, scores(d_idx, r_idx) = scores(d_idx, r_idx) + alns.reward3; end; end; if mod(iter, 50) == 0, weights = (1 - alns.reaction) * weights + alns.reaction * scores / max(1, sum(scores(:))); end; bestCostHistory(iter) = bestOverallCost; temp = temp * alns.coolingRate; end
end
parkingSpots = bestSelectedSpots;

if isempty(parkingSpots), fprintf('WARNING: No viable solution found.\n'); final_total_cost = inf; computation_time_sec = toc(computation_timer); save(fullfile(sim_params.output_dir, 'results.mat'), 'final_total_cost', 'computation_time_sec', 'sim_params'); fid = fopen(fullfile(sim_params.output_dir, 'RUN_FAILED.txt'), 'w'); fprintf(fid, 'The simulation failed to find a valid solution.'); fclose(fid); return; end

% =========================================================================
% SECTION 4: FINAL PATH & COST CALCULATION
% =========================================================================
final_JTruck_costs=zeros(numTrucks,1); final_JDrone_costs=zeros(numTrucks,1); final_truck_paths=cell(numTrucks,1); final_drone_paths=cell(numTrucks,1); final_drone_params=cell(numTrucks,1); final_drone_conv_histories=cell(numTrucks,1); final_JTruck_components=zeros(numTrucks,2); final_JDrone_components=zeros(numTrucks,4);
for t = 1:numTrucks, startPos_world=parkingSpots(t,:); targetPos_world=targetPositions(mod(t-1, size(targetPositions,1))+1,:); startPos_local=startPos_world-[xOffset_truck-xOffset_drone,yOffset_truck-yOffset_drone]; targetPos_local=targetPos_world-[xOffset_truck-xOffset_drone,yOffset_truck-yOffset_drone]; currentPackageWeight=rand()*maxPackageWeight; speedReduction=(currentPackageWeight/maxPackageWeight)*payloadSpeedFactor; droneSpeed_H=droneSpeed_H_base*(1-speedReduction); droneSpeed_V=droneSpeed_V_base*(1-speedReduction); switch sim_params.upper_level_algo, case 'BOA',[bestParams,droneMissionCost,convHistory,missionTime,costComponents]=runDroneBat(startPos_local,targetPos_local,inflatedMap_drone,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,boa,[xOffset_drone,yOffset_drone],R1,R2,k1,k2,floorSizeX,floorSizeY); case 'PSO',[bestParams,droneMissionCost,convHistory,missionTime,costComponents]=runDronePSO(startPos_local,targetPos_local,inflatedMap_drone,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,pso,[xOffset_drone,yOffset_drone],R1,R2,k1,k2,floorSizeX,floorSizeY); case 'BSO',[bestParams,droneMissionCost,convHistory,missionTime,costComponents]=runDroneBSO(startPos_local,targetPos_local,inflatedMap_drone,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,bso,[xOffset_drone,yOffset_drone],R1,R2,k1,k2,floorSizeX,floorSizeY); case 'CMAES',[bestParams,droneMissionCost,convHistory,missionTime,costComponents]=runDroneCMAES(startPos_local,targetPos_local,inflatedMap_drone,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,cmaes,[xOffset_drone,yOffset_drone],R1,R2,k1,k2,floorSizeX,floorSizeY); end; final_JDrone_costs(t)=droneMissionCost; final_drone_params{t}=bestParams; final_drone_conv_histories{t}=convHistory; final_JDrone_components(t,:)=costComponents; [truckPath_meters,truckTravelDistance]=AStarPath(truckGridMap,depotLocation,startPos_world,truckDiagFlightEnabled,worldSizeX,worldSizeY,false); final_truck_paths{t}=truckPath_meters; truckTravelTime=truckTravelDistance/truckSpeed; truckWaitTime=max(0,missionTime-truckTravelTime); final_JTruck_components(t,:)=[cost.truckPerKm*truckTravelDistance,cost.truckPerHour*truckWaitTime]; final_JTruck_costs(t)=sum(final_JTruck_components(t,:)); [pathXY_local,~]=AStarPath(inflatedMap_drone,startPos_local,targetPos_local,droneDiagFlightEnabled,floorSizeX,floorSizeY,false); [dronePath,~]=simulateDroneFlight(startPos_local,targetPos_local,bestParams,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneStayTime,gridMap_drone,[xOffset_drone,yOffset_drone],R1,R2,k1,k2,pathXY_local,droneDiagFlightEnabled); final_drone_paths{t}=dronePath; end

% =========================================================================
% SECTION 5: RESULTS ANALYSIS & PLOTTING (REVISED)
% =========================================================================
lower_level_algo_name = sim_params.lower_level_algo; upper_level_algo_name = sim_params.upper_level_algo;
fig_truck_route = figure('Name', 'Lower-Level Solution', 'NumberTitle', 'off', 'Visible', 'off', 'Position', [100, 100, 800, 700]);
ax1 = axes(fig_truck_route); hold(ax1, 'on'); truckColors = lines(numTrucks);
rectangle(ax1, 'Position',[noGo_x_start, noGo_y_start, floorSizeX, floorSizeY], 'FaceColor',[.5 .5 .5], 'EdgeColor','k');
patch(ax1, NaN, NaN, [.5 .5 .5], 'DisplayName', 'No-Go Zone');
plot(ax1, truckNetworkNodes(:,1), truckNetworkNodes(:,2), 'o', 'MarkerSize',8, 'MarkerFaceColor','b', 'MarkerEdgeColor','k', 'DisplayName','Network Nodes');
plot(ax1, parkingSpots(:,1), parkingSpots(:,2), 's', 'MarkerSize',12, 'MarkerFaceColor','r', 'MarkerEdgeColor','k', 'DisplayName','Parking Spots');
plot(ax1, depotLocation(1), depotLocation(2), 'd', 'MarkerSize',12, 'MarkerFaceColor','k', 'MarkerEdgeColor','k', 'DisplayName','Depot');
plot(ax1, targetPositions(:,1), targetPositions(:,2), 'p', 'MarkerSize',14, 'MarkerFaceColor','g', 'MarkerEdgeColor','k', 'DisplayName','Targets');
for t=1:numTrucks, if ~isempty(final_truck_paths{t}), plot(ax1, final_truck_paths{t}(:,1), final_truck_paths{t}(:,2), '--', 'LineWidth',2, 'Color',truckColors(t,:), 'DisplayName',sprintf('Truck %d Route',t)); end; end
grid(ax1, 'on'); axis(ax1, 'equal'); axis(ax1, [0 worldSizeX 0 worldSizeY]); xlabel(ax1, 'X (km)'); ylabel(ax1, 'Y (km)'); title(ax1, 'Lower-Level: Final Truck Route');
legend(ax1, 'Location', 'bestoutside'); hold(ax1, 'off');
saveFigure(fig_truck_route, fullfile(sim_params.output_dir, 'Plot_Lower_Level_Solution'), 600, 12);

fig_drone_traj = figure('Name', 'Upper-Level Solution', 'NumberTitle', 'off', 'Visible', 'off', 'Position', [900, 100, 800, 700]);
ax2 = axes(fig_drone_traj); hold(ax2, 'on');
first_obstacle_plotted = false;
for i = 1:length(obstacles)
    obs=obstacles(i); x=(obs.x-1)*gridResolution; y=(obs.y-1)*gridResolution; w=obs.w*gridResolution; h=obs.h*gridResolution; z=obs.z; vertices = [x,y,0; x+w,y,0; x+w,y+h,0; x,y+h,0; x,y,z; x+w,y,z; x+w,y+h,z; x,y+h,z]; faces = [1,2,6,5; 2,3,7,6; 3,4,8,7; 4,1,5,8; 1,2,3,4; 5,6,7,8];
    if ~first_obstacle_plotted, patch(ax2, 'Vertices',vertices, 'Faces',faces, 'FaceColor',[.3 .3 .3], 'EdgeColor','k', 'FaceAlpha', 0.7, 'DisplayName', 'Obstacles'); first_obstacle_plotted = true;
    else, patch(ax2, 'Vertices',vertices, 'Faces',faces, 'FaceColor',[.3 .3 .3], 'EdgeColor','k', 'FaceAlpha', 0.7, 'HandleVisibility', 'off'); end
end
plot3(ax2, targetPositions_local(:,1), targetPositions_local(:,2), zeros(numTargets,1), 'p', 'MarkerSize',14, 'MarkerFaceColor','g', 'MarkerEdgeColor','k', 'DisplayName','Targets');
plot3(ax2, xOffset_drone, yOffset_drone, droneCruiseAltitude, '^', 'MarkerSize', 12, 'MarkerFaceColor', 'm', 'MarkerEdgeColor', 'k', 'DisplayName', 'Tower');
for t=1:numTrucks, if ~isempty(final_drone_paths{t}), plot3(ax2, final_drone_paths{t}(:,1), final_drone_paths{t}(:,2), final_drone_paths{t}(:,3), 'Color',truckColors(t,:), 'LineWidth',2.5, 'DisplayName',sprintf('Drone %d Path',t)); end; end
grid(ax2, 'on'); view(ax2, 3); xlabel(ax2, 'X (km)'); ylabel(ax2, 'Y (km)'); zlabel(ax2, 'Z (km)'); title(ax2, 'Upper-Level: Final Drone Trajectory');
legend(ax2, 'Location', 'bestoutside'); hold(ax2, 'off');
saveFigure(fig_drone_traj, fullfile(sim_params.output_dir, 'Plot_Upper_Level_Solution'), 600, 12);

fig_lower_conv = figure('Name', [lower_level_algo_name ' Convergence'], 'NumberTitle', 'off', 'Visible', 'off');
hold on; plot(bestCostHistory, 'b-', 'LineWidth', 2.5, 'DisplayName', 'Best Cost ($)'); if ~isempty(avgCostHistory), plot(avgCostHistory, 'r--', 'LineWidth', 2, 'DisplayName', 'Average Cost ($)'); end; grid on; xlabel('Generation / Iteration'); ylabel('Total JTruck Cost ($)'); title([lower_level_algo_name ' Fitness Convergence']); legend('Location', 'bestoutside'); hold off;
saveFigure(fig_lower_conv, fullfile(sim_params.output_dir, ['Plot_' lower_level_algo_name '_Convergence']), 600, 12);

fig_upper_conv = figure('Name', [upper_level_algo_name ' Convergence'], 'NumberTitle', 'off', 'Visible', 'off');
hold on; if ~isempty(final_drone_conv_histories), for t = 1:numTrucks, if t <= length(final_drone_conv_histories), plot(final_drone_conv_histories{t}, '-o', 'LineWidth', 1.5, 'DisplayName', sprintf('Drone %d', t)); end; end; end; grid on; xlabel('Generation'); ylabel('JDrone Mission Cost ($)'); title([upper_level_algo_name ' Fitness Convergence for Final Missions']); legend('Location', 'bestoutside'); hold off;
saveFigure(fig_upper_conv, fullfile(sim_params.output_dir, ['Plot_' upper_level_algo_name '_Convergence']), 600, 12);

close(fig_truck_route, fig_drone_traj, fig_lower_conv, fig_upper_conv);

% =========================================================================
% SECTION 6 & 7: SAVE, RETURN, and ERROR HANDLING
% =========================================================================
computation_time_sec = toc(computation_timer);
final_total_cost = sum(final_JTruck_costs) + sum(final_JDrone_costs);
save(fullfile(sim_params.output_dir, 'results.mat'), 'final_total_cost', 'computation_time_sec', 'sim_params', 'final_truck_paths', 'parkingSpots', 'final_JTruck_costs', 'final_JDrone_costs', 'final_JTruck_components', 'final_JDrone_components', 'bestCostHistory', 'avgCostHistory', 'final_drone_conv_histories');
catch ME, fprintf('FATAL ERROR during simulation: %s\n', ME.message); error_filename = fullfile(sim_params.output_dir, 'FATAL_ERROR_DETAILS.txt'); fid = fopen(error_filename, 'w'); fprintf(fid, 'Error in %s_%s for seed %d.\n', sim_params.lower_level_algo, sim_params.upper_level_algo, sim_params.rng_seed); fprintf(fid, 'RNG State at start:\n'); fprintf(fid, 'Type: %s, Seed: %d\n\n', rng_state_on_start.Type, rng_state_on_start.Seed); fprintf(fid, '%s\n', ME.getReport('extended', 'hyperlinks','off')); fclose(fid); final_total_cost = inf; computation_time_sec = toc(computation_timer); rethrow(ME); end
end

% =========================================================================
% HELPER & ALGORITHM FUNCTION DEFINITIONS
% =========================================================================
function fleet_cost=calculate_truck_fleet_cost(selected_indices,nodes,targets,grid,depot,diag,wX,wY,tSpeed,drone_map,cost,alt,dSH,dSV,dDiag,dStay,dBatt,iBatt,tower,r1,r2,k1,k2,fX,fY,oX,oY,maxW,pFactor,up_algo,boa,pso,bso,cmaes),num_trucks=length(selected_indices);cost_per_truck=zeros(num_trucks,1);for t=1:num_trucks,parkingNodeIndex=selected_indices(t);startNode=nodes(parkingNodeIndex,:);truckTarget=targets(mod(t-1,size(targets,1))+1,:);[~,truckTravelDistance]=AStarPath(grid,depot,startNode,diag,wX,wY,false);if isinf(truckTravelDistance),cost_per_truck(t)=1e9;continue;end;truckTravelTime=truckTravelDistance/tSpeed;startNode_local=startNode-[oX-fX/2,oY-fY/2];currentPackageWeight=rand()*maxW;speedReduction=(currentPackageWeight/maxW)*pFactor;droneSpeed_H=dSH*(1-speedReduction);droneSpeed_V=dSV*(1-speedReduction);missionTime=inf;switch up_algo,case 'BOA',[~,~,~,missionTime,~]=runDroneBat(startNode_local,truckTarget,drone_map,cost,alt,droneSpeed_H,droneSpeed_V,dDiag,dStay,dBatt,iBatt,boa,tower,r1,r2,k1,k2,fX,fY);case 'PSO',[~,~,~,missionTime,~]=runDronePSO(startNode_local,truckTarget,drone_map,cost,alt,droneSpeed_H,droneSpeed_V,dDiag,dStay,dBatt,iBatt,pso,tower,r1,r2,k1,k2,fX,fY);case 'BSO',[~,~,~,missionTime,~]=runDroneBSO(startNode_local,truckTarget,drone_map,cost,alt,droneSpeed_H,droneSpeed_V,dDiag,dStay,dBatt,iBatt,bso,tower,r1,r2,k1,k2,fX,fY);case 'CMAES',[~,~,~,missionTime,~]=runDroneCMAES(startNode_local,truckTarget,drone_map,cost,alt,droneSpeed_H,droneSpeed_V,dDiag,dStay,dBatt,iBatt,cmaes,tower,r1,r2,k1,k2,fX,fY);end;truckWaitTime=max(0,missionTime-truckTravelTime);JTruck=(cost.truckPerKm*truckTravelDistance)+(cost.truckPerHour*truckWaitTime);cost_per_truck(t)=JTruck;end;fleet_cost=cost_per_truck;end
function [partial_solution, removed_nodes]=destroy_random(solution,q,varargin),removed_indices=randperm(length(solution),q);removed_nodes=solution(removed_indices);partial_solution=solution;partial_solution(removed_indices)=[];end
function [partial_solution, removed_nodes]=destroy_worst(solution,q,nodes,varargin),costs=zeros(length(solution),1);for i=1:length(solution),costs(i)=norm(nodes(solution(i),:)-[6,6]);end;[~,sorted_indices]=sort(costs,'descend');removed_indices=sorted_indices(1:q);removed_nodes=solution(removed_indices);partial_solution=solution;partial_solution(removed_indices)=[];end
function new_solution=repair_random(partial_solution,numNodes,~),available_nodes=setdiff(1:numNodes,partial_solution);nodes_to_add=randsample(available_nodes,5-length(partial_solution));new_solution=[partial_solution,nodes_to_add];end
function new_solution=repair_greedy(partial_solution,numNodes,nodes,varargin),new_solution=partial_solution;available_nodes=setdiff(1:numNodes,partial_solution);for i=1:(5-length(partial_solution)),best_node=-1;min_cost_increase=inf;for j=1:length(available_nodes),node_to_try=available_nodes(j);cost_increase=norm(nodes(node_to_try,:)-[6,6]);if cost_increase<min_cost_increase,min_cost_increase=cost_increase;best_node=node_to_try;end;end;new_solution=[new_solution,best_node];available_nodes(available_nodes==best_node)=[];end;end
function idx=roulette_wheel_selection(weights),if sum(weights)==0||any(isnan(weights)),weights=ones(size(weights));end;p=weights(:)'/sum(weights);idx=find(rand<=cumsum(p),1,'first');end
function [bestParams,minCost,costHistory,missionTime,costComponents]=runDroneCMAES(startPos,targetPos,gridMap,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,cmaes,towerPosition,R1,R2,k1,k2,droneMapX,droneMapY),nVar=3;varMin=[0.5,0.5,0.5];varMax=[2.0,2.0,2.0];costHistory=zeros(cmaes.maxGenerations,1);[pathXY,~]=AStarPath(gridMap,startPos,targetPos,droneDiagFlightEnabled,droneMapX,droneMapY,false);if isempty(pathXY),minCost=1e10;bestParams=[1,1,1];costHistory(:)=minCost;missionTime=inf;costComponents=[inf,inf,inf,inf];return;end;lambda=cmaes.populationSize;mu=floor(lambda/2);weights=log(mu+1/2)-log(1:mu)';weights=weights/sum(weights);mueff=sum(weights)^2/sum(weights.^2);mean_pos=(varMin+varMax)/2;sigma=cmaes.sigma;C=eye(nVar);pc=zeros(nVar,1);ps=zeros(nVar,1);cc=(4+mueff/nVar)/(nVar+4+2*mueff/nVar);cs=(mueff+2)/(nVar+mueff+5);c1=2/((nVar+1.3)^2+mueff);cmu=min(1-c1,2*(mueff-2+1/mueff)/((nVar+2)^2+mueff));damps=1+2*max(0,sqrt((mueff-1)/(nVar+1))-1)+cs;minCost=inf;bestParams=mean_pos;for gen=1:cmaes.maxGenerations,population=zeros(nVar,lambda);costs=zeros(lambda,1);for i=1:lambda,population(:,i)=mean_pos'+sigma*(C^(1/2)*randn(nVar,1));population(:,i)=max(population(:,i),varMin');population(:,i)=min(population(:,i),varMax');costs(i)=JDroneCost(population(:,i)',startPos,targetPos,gridMap,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,towerPosition,R1,R2,k1,k2,pathXY);end;[sorted_costs,sort_idx]=sort(costs);if sorted_costs(1)<minCost,minCost=sorted_costs(1);bestParams=population(:,sort_idx(1))';end;old_mean=mean_pos;mean_pos=(population(:,sort_idx(1:mu))*weights)';ps=(1-cs)*ps+sqrt(cs*(2-cs)*mueff)*(C^(-1/2)*(mean_pos-old_mean)'/sigma);hsig=norm(ps)/sqrt(1-(1-cs)^(2*gen))/((nVar+4)/(nVar+4)+0.5)<1.4+2/(nVar+1);pc=(1-cc)*pc+hsig*sqrt(cc*(2-cc)*mueff)*(mean_pos-old_mean)'/sigma;artmp=(1/sigma)*(population(:,sort_idx(1:mu))-repmat(old_mean',1,mu));C=(1-c1-cmu)*C+c1*(pc*pc'+(1-hsig)*cc*(2-cc)*C)+cmu*artmp*diag(weights)*artmp';sigma=sigma*exp((cs/damps)*(norm(ps)/((nVar+4)/(nVar+4)+0.5)-1));costHistory(gen)=minCost;end;[minCost,missionTime,costComponents]=JDroneCost(bestParams,startPos,targetPos,gridMap,cost,droneCruiseAltitude,droneSpeed_H,droneSpeed_V,droneDiagFlightEnabled,droneStayTime,droneBatteryMin,initialBattery,towerPosition,R1,R2,k1,k2,pathXY);end
function [bestParams, minCost, costHistory, missionTime, costComponents] = runDroneBat(startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, boa, towerPosition, R1, R2, k1, k2, droneMapX, droneMapY), nVar = 3; varMin = [0.5, 0.5, 0.5]; varMax = [2.0, 2.0, 2.0]; bats = struct('Position', {}, 'Velocity', {}, 'Loudness', {}, 'PulseRate', {}, 'Cost', {}); costHistory=zeros(boa.maxGenerations,1); [pathXY, ~] = AStarPath(gridMap, startPos, targetPos, droneDiagFlightEnabled, droneMapX, droneMapY, false); if isempty(pathXY), minCost = 1e10; bestParams = [1, 1, 1]; costHistory(:)=minCost; missionTime = inf; costComponents=[inf,inf,inf,inf]; return; end; for i = 1:boa.populationSize, bats(i).Position = varMin + (varMax - varMin).* rand(1, nVar); bats(i).Velocity = zeros(1, nVar); bats(i).Loudness = boa.loudness; bats(i).PulseRate = boa.pulseRate; try, [bats(i).Cost, ~] = JDroneCost(bats(i).Position, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); catch, bats(i).Cost = 1e10; end; end; [minCost, bestBatIdx] = min([bats.Cost]); bestParams = bats(bestBatIdx).Position; stagnation_counter = 0; for gen = 1:boa.maxGenerations, last_min_cost = minCost; for i = 1:boa.populationSize, newF = boa.fmin + (boa.fmax - boa.fmin) * rand; bats(i).Velocity = bats(i).Velocity + (bats(i).Position - bestParams) * newF; newPos = bats(i).Position + bats(i).Velocity; newPos = max(newPos, varMin); newPos = min(newPos, varMax); if rand > bats(i).PulseRate, newPos = bestParams + 0.1 * randn(1, nVar); newPos = max(newPos, varMin); newPos = min(newPos, varMax); end; try, [newCost, ~] = JDroneCost(newPos, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); catch, newCost = 1e10; end; if newCost < bats(i).Cost && rand < bats(i).Loudness, bats(i).Position = newPos; bats(i).Cost = newCost; bats(i).Loudness = bats(i).Loudness * 0.9; bats(i).PulseRate = boa.pulseRate * (1 - exp(-gen/boa.maxGenerations)); end; end; [minCost, bestBatIdx] = min([bats.Cost]); bestParams = bats(bestBatIdx).Position; if minCost >= last_min_cost, stagnation_counter = stagnation_counter + 1; else, stagnation_counter = 0; end; if stagnation_counter >= 7, [~, sortOrder] = sort([bats.Cost], 'descend'); for i = 1:floor(boa.populationSize/2), bats(sortOrder(i)).Position = varMin + (varMax - varMin).* rand(1, nVar); try, [bats(sortOrder(i)).Cost, ~] = JDroneCost(bats(sortOrder(i)).Position, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); catch, bats(sortOrder(i)).Cost = 1e10; end; end; stagnation_counter = 0; end; costHistory(gen)=minCost; end; [minCost, missionTime, costComponents] = JDroneCost(bestParams, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); end
function [gBestPos, gBestCost, costHistory, missionTime, costComponents] = runDronePSO(startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, pso, towerPosition, R1, R2, k1, k2, droneMapX, droneMapY), nVar = 3; varMin = [0.5, 0.5, 0.5]; varMax = [2.0, 2.0, 2.0]; particles = struct('Position', {}, 'Velocity', {}, 'Cost', {}, 'pBestPos', {}, 'pBestCost', {}); costHistory = zeros(pso.maxGenerations, 1); [pathXY, ~] = AStarPath(gridMap, startPos, targetPos, droneDiagFlightEnabled, droneMapX, droneMapY, false); if isempty(pathXY), gBestPos = [1,1,1]; gBestCost = 1e10; costHistory(:)=gBestCost; missionTime = inf; costComponents=[inf,inf,inf,inf]; return; end; gBestCost = inf; gBestPos = []; for i = 1:pso.populationSize, particles(i).Position = varMin + (varMax - varMin) .* rand(1, nVar); particles(i).Velocity = zeros(1, nVar); [particles(i).Cost, ~] = JDroneCost(particles(i).Position, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); particles(i).pBestPos = particles(i).Position; particles(i).pBestCost = particles(i).Cost; if particles(i).pBestCost < gBestCost, gBestCost = particles(i).pBestCost; gBestPos = particles(i).pBestPos; end; end; for gen = 1:pso.maxGenerations, for i = 1:pso.populationSize, particles(i).Velocity = pso.inertia * particles(i).Velocity + pso.cognition * rand() * (particles(i).pBestPos - particles(i).Position) + pso.social * rand() * (gBestPos - particles(i).Position); particles(i).Position = particles(i).Position + particles(i).Velocity; particles(i).Position = max(particles(i).Position, varMin); particles(i).Position = min(particles(i).Position, varMax); [particles(i).Cost, ~] = JDroneCost(particles(i).Position, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); if particles(i).Cost < particles(i).pBestCost, particles(i).pBestPos = particles(i).Position; particles(i).pBestCost = particles(i).Cost; if particles(i).pBestCost < gBestCost, gBestCost = particles(i).pBestCost; gBestPos = particles(i).pBestPos; end; end; end; costHistory(gen) = gBestCost; end; [gBestCost, missionTime, costComponents] = JDroneCost(gBestPos, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); end
function [gBestPos, gBestCost, costHistory, missionTime, costComponents] = runDroneBSO(startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, bso, towerPosition, R1, R2, k1, k2, droneMapX, droneMapY), nVar = 3; varMin = [0.5, 0.5, 0.5]; varMax = [2.0, 2.0, 2.0]; costHistory = zeros(bso.maxGenerations, 1); [pathXY, ~] = AStarPath(gridMap, startPos, targetPos, droneDiagFlightEnabled, droneMapX, droneMapY, false); if isempty(pathXY), gBestPos = [1,1,1]; gBestCost = 1e10; costHistory(:)=gBestCost; missionTime = inf; costComponents=[inf,inf,inf,inf]; return; end; individuals = varMin + (varMax - varMin) .* rand(bso.populationSize, nVar); costs = zeros(bso.populationSize, 1); for i = 1:bso.populationSize, [costs(i), ~] = JDroneCost(individuals(i,:), startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); end; [gBestCost, gBestIdx] = min(costs); gBestPos = individuals(gBestIdx,:); for gen = 1:bso.maxGenerations, [cluster_idx, ~] = kmeans(individuals, bso.numClusters, 'emptyaction', 'singleton'); new_individuals = individuals; for i = 1:bso.populationSize, r = rand(); if r < bso.p_one_cluster, selected_cluster = randi(bso.numClusters); cluster_members = individuals(cluster_idx == selected_cluster, :); new_individuals(i,:) = cluster_members(randi(size(cluster_members,1)),:) + 0.5 * randn(1, nVar); else, r2 = rand(); selected_cluster = cluster_idx(i); if r2 < bso.p_one_center, same_cluster_indices = find(cluster_idx == selected_cluster); rand_ind_idx = same_cluster_indices(randi(length(same_cluster_indices))); new_individuals(i,:) = individuals(rand_ind_idx,:) + 0.5 * randn(1, nVar); elseif r2 < bso.p_one_center + bso.p_two_centers, same_cluster_indices = find(cluster_idx == selected_cluster); if length(same_cluster_indices) >= 2, p_indices = randperm(length(same_cluster_indices), 2); p1 = individuals(same_cluster_indices(p_indices(1)),:); p2 = individuals(same_cluster_indices(p_indices(2)),:); new_individuals(i,:) = rand()*p1 + (1-rand())*p2; else, new_individuals(i,:) = individuals(same_cluster_indices(1),:) + 0.5 * randn(1, nVar); end; else, other_clusters = 1:bso.numClusters; other_clusters(selected_cluster) = []; rand_cluster_idx = other_clusters(randi(length(other_clusters))); cluster1_indices = find(cluster_idx == selected_cluster); cluster2_indices = find(cluster_idx == rand_cluster_idx); p1 = individuals(cluster1_indices(randi(length(cluster1_indices))),:); p2 = individuals(cluster2_indices(randi(length(cluster2_indices))),:); new_individuals(i,:) = rand()*p1 + (1-rand())*p2; end; end; new_individuals(i,:) = max(new_individuals(i,:), varMin); new_individuals(i,:) = min(new_individuals(i,:), varMax); end; for i = 1:bso.populationSize, [new_cost, ~] = JDroneCost(new_individuals(i,:), startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); if new_cost < costs(i), individuals(i,:) = new_individuals(i,:); costs(i) = new_cost; end; end; [current_best_cost, current_best_idx] = min(costs); if current_best_cost < gBestCost, gBestCost = current_best_cost; gBestPos = individuals(current_best_idx,:); end; costHistory(gen) = gBestCost; end; [gBestCost, missionTime, costComponents] = JDroneCost(gBestPos, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); end
function [costVal, totalTime, components] = JDroneCost(params, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY), [~, droneTimeVec, ~, batteryConsumptionPerStep, obstaclePenaltySum, signalPenaltySum] = simulateDroneFlight(startPos, targetPos, params, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap, towerPosition, R1, R2, k1, k2, pathXY, droneDiagFlightEnabled); if isempty(droneTimeVec), totalTime = inf; else, totalTime = droneTimeVec(end); end; timeCost = totalTime * cost.dronePerHour; obstacleCost = obstaclePenaltySum * cost.obstaclePenalty; remainingBattery = initialBattery - cumsum(batteryConsumptionPerStep); remainingBattery(remainingBattery < droneBatteryMin) = droneBatteryMin; batteryUsageIntegral = sum(1 ./ remainingBattery); batteryCost = batteryUsageIntegral * cost.batteryPenalty; signalCost = signalPenaltySum * cost.signalPenalty; costVal = timeCost + obstacleCost + batteryCost + signalCost; components = [timeCost, batteryCost, obstacleCost, signalCost]; end
function [path_meters, totalDistance] = AStarPath(gridMap, startPos, targetPos, diagEnabled, worldX, worldY, ~), [rows, cols] = size(gridMap); gridResolution_x = worldX / cols; gridResolution_y = worldY / rows; startIdx = floor(startPos ./ [gridResolution_x, gridResolution_y]) + 1; targetIdx = floor(targetPos ./ [gridResolution_x, gridResolution_y]) + 1; startIdx(1) = max(1, min(cols, startIdx(1))); startIdx(2) = max(1, min(rows, startIdx(2))); targetIdx(1) = max(1, min(cols, targetIdx(1))); targetIdx(2) = max(1, min(rows, targetIdx(2))); if gridMap(startIdx(2), startIdx(1)) == 1 || gridMap(targetIdx(2), targetIdx(1)) == 1, path_meters = []; totalDistance = inf; return; end; openSet = priority_queue(); openSet.insert(startIdx, 0); gScore = inf(rows, cols); gScore(startIdx(2), startIdx(1)) = 0; cameFrom = zeros(rows, cols, 2); path = []; while ~openSet.isempty(), currentIdx = openSet.extract_min(); if isequal(currentIdx, targetIdx), path = []; current = currentIdx; while ~isequal(current, startIdx), path = [path; current]; current = squeeze(cameFrom(current(2), current(1), :))'; end; path = [path; startIdx]; path = flipud(path); break; end; neighbors = getNeighbors(currentIdx, diagEnabled, rows, cols); for i = 1:size(neighbors, 1), neighbor = neighbors(i, :); if neighbor(1) < 1 || neighbor(1) > cols || neighbor(2) < 1 || neighbor(2) > rows, continue; end; if gridMap(neighbor(2), neighbor(1)) == 1, continue; end; dist = norm((currentIdx - neighbor) .* [gridResolution_x, gridResolution_y]); tentative_gScore = gScore(currentIdx(2), currentIdx(1)) + dist; if tentative_gScore < gScore(neighbor(2), neighbor(1)), cameFrom(neighbor(2), neighbor(1), :) = currentIdx; gScore(neighbor(2), neighbor(1)) = tentative_gScore; hScore = norm((neighbor - targetIdx) .* [gridResolution_x, gridResolution_y]); fScore = tentative_gScore + hScore; if ~openSet.contains(neighbor), openSet.insert(neighbor, fScore); end; end; end; end; if isempty(path), path_meters = []; totalDistance = inf; else, path_meters = (path - 1) .* [gridResolution_x, gridResolution_y]; totalDistance = 0; for i = 1:size(path_meters, 1) - 1, totalDistance = totalDistance + norm(path_meters(i, :) - path_meters(i+1, :)); end; end; end
function neighbors = getNeighbors(node, diagEnabled, ~, ~), [x, y] = deal(node(1), node(2)); if diagEnabled, [dx, dy] = meshgrid(-1:1, -1:1); neighbors_rel = [dx(:), dy(:)]; neighbors_rel(5,:) = []; else, neighbors_rel = [-1, 0; 1, 0; 0, -1; 0, 1]; end; neighbors = [x,y] + neighbors_rel; end
function [dronePath, droneTime, totalDistance, batteryConsumptionPerStep, obstaclePenaltySum, signalPenaltySum] = simulateDroneFlight(startPos, targetPos, params, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap, towerPosition, R1, R2, k1, k2, pathXY, ~), h_vel_scale=params(1); v_vel_scale_ascent=params(2); v_vel_scale_descent=params(3); gridResolution=0.1; ascentSpeed=droneSpeed_V*v_vel_scale_ascent; ascentTime=droneCruiseAltitude/ascentSpeed; numStepsAscent=max(2,round(ascentTime/(gridResolution/droneSpeed_V))); z_ascent=linspace(0,droneCruiseAltitude,numStepsAscent); path_ascent=[repmat(startPos(1),numStepsAscent,1),repmat(startPos(2),numStepsAscent,1),z_ascent']; time_ascent=linspace(0,ascentTime,numStepsAscent)'; horizSpeed=droneSpeed_H*h_vel_scale; path_horiz=[pathXY,repmat(droneCruiseAltitude,size(pathXY,1),1)]; if size(pathXY,1)>1, dist_segments=vecnorm(diff(pathXY,1,1),2,2); time_segments=dist_segments/horizSpeed; time_horiz=[0;cumsum(time_segments)]; else, time_horiz=0; end; descentSpeed=droneSpeed_V*v_vel_scale_descent; descentTime=droneCruiseAltitude/descentSpeed; numStepsDescent=max(2,round(descentTime/(gridResolution/droneSpeed_V))); z_descent=linspace(droneCruiseAltitude,0,numStepsDescent); path_descent=[repmat(targetPos(1),numStepsDescent,1),repmat(targetPos(2),numStepsDescent,1),z_descent']; time_descent=linspace(0,descentTime,numStepsDescent)'; dronePath=path_ascent; droneTime=time_ascent; if size(path_horiz,1)>1, dronePath=[dronePath;path_horiz(2:end,:)]; droneTime=[droneTime;droneTime(end)+time_horiz(2:end)]; end; dronePath=[dronePath;path_descent(2:end,:)]; droneTime=[droneTime;droneTime(end)+time_descent(2:end)]; dronePath=[dronePath;dronePath(end,:)]; droneTime=[droneTime;droneTime(end)+droneStayTime]; totalDistance=0; if size(dronePath,1)>1, for i=1:size(dronePath,1)-1,totalDistance=totalDistance+norm(dronePath(i,:)-dronePath(i+1,:));end; end; batteryConsumptionPerStep=zeros(size(dronePath,1),1); obstaclePenaltySum=0; signalPenaltySum=0; len_ascent_pts=size(path_ascent,1); len_horiz_pts=size(path_horiz,1); if isempty(pathXY),len_horiz_pts=0; end; for i=1:size(dronePath,1), currentPos_2D=dronePath(i,1:2); gridX_curr=max(1,min(size(gridMap,2),floor(currentPos_2D(1)/gridResolution)+1)); gridY_curr=max(1,min(size(gridMap,1),floor(currentPos_2D(2)/gridResolution)+1)); if gridMap(gridY_curr,gridX_curr)==1, obstaclePenaltySum=obstaclePenaltySum+1; end; distToTower=norm(currentPos_2D-towerPosition); if distToTower>R2, signalPenaltySum=signalPenaltySum+k2; elseif distToTower>R1, signalPenaltySum=signalPenaltySum+k1*(distToTower-R1)^2; end; len_horiz_segment=max(0,len_horiz_pts-1); if i<=len_ascent_pts,batt_step=0.001+0.0005*v_vel_scale_ascent^2; elseif i<=len_ascent_pts+len_horiz_segment,batt_step=0.001+0.0005*h_vel_scale^2; else, batt_step=0.001+0.0005*v_vel_scale_descent^2; end; batteryConsumptionPerStep(i)=batt_step; end; end
function saveFigure(figHandle, filename_base, dpi, fontsize), set(findall(figHandle, '-property', 'FontSize'), 'FontSize', fontsize); try, savefig(figHandle, [filename_base '.fig']); exportgraphics(figHandle, [filename_base '.png'], 'Resolution', dpi); catch ME, fprintf('Could not save figure %s. Error: %s\n', filename_base, ME.message); end; end