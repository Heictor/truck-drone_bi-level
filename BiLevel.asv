% =========================================================================
% BI-LEVEL OPTIMIZATION FOR TRUCK-DRONE LAST-MILE DELIVERY
%
% This script implements a bi-level optimization model for a last-mile
% delivery scenario.
%
% Lower-Level: Truck Routing with a Genetic Algorithm (GA) to minimize the
%              JTruck cost function in USD.
% Upper-Level: Drone Path Planning with A* Search to find the shortest,
%              safest path, optimized by a Bat Algorithm (BOA) to minimize
%              a total mission cost in USD.
%
% All units are in kilometers (km), hours (h), and US Dollars ($).
% =========================================================================
clear; close all; clc;
% =========================================================================
% SECTION 1: SYSTEM PARAMETERS AND SETUP
% =========================================================================
% General Simulation Parameters
floorSizeX = 5;
floorSizeY = 5; 
gridResolution = 0.1;

% Drone-specific map dimensions
gridSizeX_drone = floor(floorSizeX / gridResolution);
gridSizeY_drone = floor(floorSizeY / gridResolution);
xOffset_drone = floorSizeX / 2;
yOffset_drone = floorSizeY / 2;

% Truck-specific map dimensions
worldSizeX = 12;
worldSizeY = 12;
gridSizeX_truck = floor(worldSizeX / gridResolution);
gridSizeY_truck = floor(worldSizeY / gridResolution);
xOffset_truck = worldSizeX / 2;
yOffset_truck = worldSizeY / 2;

% Tunable Target Parameters
numTargets = 10; % TUNABLE: Number of customers

% Truck Parameters (Lower-Level)
numTrucks = numTargets;
numNodes = 20; 
numParkingSpots = numTrucks; 
truckSpeed = 36.0; % km/h (approx. 22 mph)
truckDiagFlightEnabled = false; 

% Drone Parameters (Upper-Level)
numDrones = numTrucks;
droneSpeed_H = 18.0; % Horizontal speed in km/h
droneSpeed_V = 7.2;  % Vertical speed in km/h
droneCruiseAltitude = 0.120; % km (120 meters)
droneStayTime = 5 / 3600;    % 5 seconds, converted to hours
droneBatteryMin = 0.1; 
initialBattery = 1.0; 
droneDiagFlightEnabled = true;
droneSafetyRadius = 0.005; % km (5 meters)

% Real-World Cost Parameters (USD)
cost = struct();
cost.truckPerKm = 1.50;         % Cost per km for fuel, maintenance, driver
cost.truckPerHour = 25.00;      % Cost per hour for idle truck + driver
cost.dronePerHour = 20.00;      % Operational cost for drone flight
cost.obstaclePenalty = 1000.00; % High penalty for risk of collision
cost.batteryPenalty = 0.10;    
cost.signalPenalty = 500.00;    % High penalty for risk of losing signal

% Genetic Algorithm Parameters
ga.populationSize = 50;
ga.maxGenerations = 10;
ga.mutationRate = 0.1;

% Bat Optimization Algorithm Parameters
boa.populationSize = 20;
boa.maxGenerations = 10;
boa.fmin = 0; boa.fmax = 2;
boa.loudness = 0.5;
boa.pulseRate = 0.5;

% Signal Coverage Penalty Parameters
R1 = 8; % Safe range (no penalty) in km
R2 = 10; % Max range (small penalty) in km
k1 = 0.1; 
k2 = 100;
% =========================================================================
% SECTION 2: ENVIRONMENT AND NODE GENERATION
% =========================================================================
% --- Generate Randomized Target Positions ---
targetPositions = zeros(numTargets, 2);
for i = 1:numTargets
    targetPositions(i, 1) = (rand() * floorSizeX) + (xOffset_truck - xOffset_drone);
    targetPositions(i, 2) = (rand() * floorSizeY) + (yOffset_truck - yOffset_drone);
end
targetPositions_local = targetPositions - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone];
target_indices_local = floor(targetPositions_local / gridResolution) + 1;

% --- MAP 1: Drone Operating Area with Varied Obstacles and Target Safety Check ---
gridMap_drone = false(gridSizeY_drone, gridSizeX_drone);
obstacles = struct('x', {}, 'y', {}, 'w', {}, 'h', {}, 'z', {});
numObstacles = 50;
safetyRadius_cells = ceil(droneSafetyRadius / gridResolution);
for i = 1:numObstacles
    isPlacementValid = false;
    while ~isPlacementValid
        obsW_km = 0.1 + rand()*0.3; obsH_km = 0.1 + rand()*0.3;
        obsW = floor(obsW_km / gridResolution); obsH = floor(obsH_km / gridResolution);
        obsX = randi(gridSizeX_drone - obsW); obsY = randi(gridSizeY_drone - obsH);
        isClearOfTargets = true;
        expanded_x_min = obsX - safetyRadius_cells; expanded_x_max = obsX + obsW - 1 + safetyRadius_cells;
        expanded_y_min = obsY - safetyRadius_cells; expanded_y_max = obsY + obsH - 1 + safetyRadius_cells;
        for j = 1:numTargets
            tx = target_indices_local(j, 1); ty = target_indices_local(j, 2);
            if (tx >= expanded_x_min && tx <= expanded_x_max && ty >= expanded_y_min && ty <= expanded_y_max)
                isClearOfTargets = false; break;
            end
        end
        if isClearOfTargets
            isPlacementValid = true;
            obsZ = (0.024 + rand() * 0.084);
            gridMap_drone(obsY:obsY+obsH-1, obsX:obsX+obsW-1) = true;
            obstacles(end+1) = struct('x', obsX, 'y', obsY, 'w', obsW, 'h', obsH, 'z', obsZ);
        end
    end
end

% --- Inflate Drone Map for Safety Radius ---
inflatedMap_drone = gridMap_drone;
[obs_y, obs_x] = find(gridMap_drone);
for i = 1:length(obs_x)
    for dy = -safetyRadius_cells:safetyRadius_cells
        for dx = -safetyRadius_cells:safetyRadius_cells
            if sqrt(dx^2 + dy^2) <= safetyRadius_cells
                ny = obs_y(i) + dy; nx = obs_x(i) + dx;
                if ny > 0 && ny <= gridSizeY_drone && nx > 0 && nx <= gridSizeX_drone, inflatedMap_drone(ny, nx) = true; end
            end
        end
    end
end

% --- MAP 2: Truck Road Network ---
truckGridMap = false(gridSizeY_truck, gridSizeX_truck);
noGo_x_start = (xOffset_truck - floorSizeX/2); noGo_y_start = (yOffset_truck - floorSizeY/2);
noGo_x_start_idx = floor(noGo_x_start / gridResolution) + 1;
noGo_x_end_idx = floor((xOffset_truck + floorSizeX/2) / gridResolution) + 1;
noGo_y_start_idx = floor(noGo_y_start / gridResolution) + 1;
noGo_y_end_idx = floor((yOffset_truck + floorSizeY/2) / gridResolution) + 1;
truckGridMap(noGo_y_start_idx:noGo_y_end_idx, noGo_x_start_idx:noGo_x_end_idx) = true;

% --- Node and Depot Generation ---
centralPoint = [xOffset_truck, yOffset_truck];
nodeRadius = 4.0; % km
truckNetworkNodes = zeros(numNodes, 2);
for i = 1:numNodes, angle = 2 * pi * i / numNodes; truckNetworkNodes(i, :) = centralPoint + nodeRadius * [cos(angle), sin(angle)]; end
depotLocation = [xOffset_truck, yOffset_truck + 5.0];

% =========================================================================
% SECTION 3: LOWER-LEVEL OPTIMIZATION (TRUCK ROUTING - GA)
% =========================================================================
bestOverallCost = inf; bestOverallRoute = cell(numTrucks, 1); bestSelectedSpots = []; 
bestCostHistory = zeros(ga.maxGenerations, 1); avgCostHistory = zeros(ga.maxGenerations, 1);
if isempty(gcp('nocreate')), parpool; end
fprintf('Starting GA optimization...\n');
for gen = 1:ga.maxGenerations
    if gen == 1, population = zeros(ga.populationSize, numNodes); for p = 1:ga.populationSize, population(p, :) = randperm(numNodes); end
    else
        [~, sortedIndices] = sort(sum(costMatrix, 1)); newPopulation = population(sortedIndices(1:ga.populationSize/2), :);
        for i = 1:ga.populationSize/2
            parent1 = newPopulation(randi(size(newPopulation, 1)), :); parent2 = newPopulation(randi(size(newPopulation, 1)), :); crossoverPoint = randi(numNodes-1);
            child = zeros(1, numNodes); child(1:crossoverPoint) = parent1(1:crossoverPoint); p2_elements = parent2(~ismember(parent2, child));
            if numNodes - crossoverPoint <= length(p2_elements), child(crossoverPoint+1:end) = p2_elements(1:numNodes-crossoverPoint);
            else, child(crossoverPoint+1:end) = p2_elements(1:min(length(p2_elements), numNodes-crossoverPoint)); end
            newPopulation(i+ga.populationSize/2, :) = child;
        end
        for i = ga.populationSize/2 + 1 : ga.populationSize, if rand < ga.mutationRate, mutationPoints = randperm(numNodes, 2); temp = newPopulation(i, mutationPoints(1)); newPopulation(i, mutationPoints(1)) = newPopulation(i, mutationPoints(2)); newPopulation(i, mutationPoints(2)) = temp; end; end
        population = newPopulation;
    end
    costMatrix = zeros(numTrucks, ga.populationSize);
    parfor p = 1:ga.populationSize
        currentRouteIndices = population(p, :); currentCostForIndividual = zeros(numTrucks, 1); selectedParkingNodeIndices = currentRouteIndices(1:numTrucks);
        for t = 1:numTrucks
            parkingNodeIndex = selectedParkingNodeIndices(t); startNode = truckNetworkNodes(parkingNodeIndex, :); truckTarget = targetPositions(mod(t-1, size(targetPositions, 1)) + 1, :);
            [~, truckTravelDistance] = AStarPath(truckGridMap, depotLocation, startNode, truckDiagFlightEnabled, worldSizeX, worldSizeY, false);
            if isinf(truckTravelDistance), currentCostForIndividual(t) = 1e9; continue; end
            truckTravelTime = truckTravelDistance / truckSpeed;
            startNode_local = startNode - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone]; truckTarget_local = truckTarget - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone];
            
            % CORRECTED: Capture all outputs from runDroneBat to get missionTime
            [~, ~, ~, missionTime, ~] = runDroneBat(startNode_local, truckTarget_local, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, boa, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY);
            
            truckWaitTime = max(0, missionTime - truckTravelTime);
            JTruck = (cost.truckPerKm * truckTravelDistance) + (cost.truckPerHour * truckWaitTime);
            currentCostForIndividual(t) = JTruck;
        end
        costMatrix(:, p) = currentCostForIndividual;
    end
    totalCosts = sum(costMatrix, 1); bestCostHistory(gen) = min(totalCosts); avgCostHistory(gen) = mean(totalCosts);
    [minGenCost, bestIdx] = min(totalCosts);
    if minGenCost < bestOverallCost, bestOverallCost = minGenCost; bestRouteIndices = population(bestIdx, :); bestSelectedSpots = truckNetworkNodes(bestRouteIndices(1:numTrucks), :); end
    fprintf('Generation %d/%d: Best Cost = $%.2f\n', gen, ga.maxGenerations, bestCostHistory(gen));
end
parkingSpots = bestSelectedSpots;
% =========================================================================
% SECTION 4: FINAL PATH & COST CALCULATION
% =========================================================================
final_JTruck_costs = zeros(numTrucks, 1); final_JDrone_costs = zeros(numTrucks, 1);
final_truck_paths = cell(numTrucks, 1); final_drone_paths = cell(numTrucks, 1);
final_drone_params = cell(numTrucks, 1); final_drone_conv_histories = cell(numTrucks, 1);
final_JTruck_components = zeros(numTrucks, 2); 
final_JDrone_components = zeros(numTrucks, 4);

for t = 1:numTrucks
    startPos_world = parkingSpots(t, :);
    targetPos_world = targetPositions(mod(t-1, size(targetPositions, 1)) + 1, :);
    startPos_local = startPos_world - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone];
    targetPos_local = targetPos_world - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone];
    [bestParams, droneMissionCost, convHistory, missionTime, costComponents] = runDroneBat(startPos_local, targetPos_local, inflatedMap_drone, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, boa, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, floorSizeX, floorSizeY);
    final_JDrone_costs(t) = droneMissionCost;
    final_drone_params{t} = bestParams;
    final_drone_conv_histories{t} = convHistory;
    final_JDrone_components(t, :) = costComponents;
    [truckPath_meters, truckTravelDistance] = AStarPath(truckGridMap, depotLocation, startPos_world, truckDiagFlightEnabled, worldSizeX, worldSizeY, false);
    final_truck_paths{t} = truckPath_meters;
    truckTravelTime = truckTravelDistance / truckSpeed;
    truckWaitTime = max(0, missionTime - truckTravelTime);
    final_JTruck_components(t,:) = [cost.truckPerKm * truckTravelDistance, cost.truckPerHour * truckWaitTime];
    final_JTruck_costs(t) = sum(final_JTruck_components(t,:));
    [pathXY_local, ~] = AStarPath(inflatedMap_drone, startPos_local, targetPos_local, droneDiagFlightEnabled, floorSizeX, floorSizeY, false);
    [dronePath, ~] = simulateDroneFlight(startPos_local, targetPos_local, bestParams, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap_drone, [xOffset_drone, yOffset_drone], R1, R2, k1, k2, pathXY_local, droneDiagFlightEnabled);
    final_drone_paths{t} = dronePath;
end
fprintf('\n======================================================\n');
fprintf('     FINAL OPTIMIZED MISSION REPORT\n');
fprintf('======================================================\n');
fprintf('Overall Optimal Fleet Cost: $%.2f\n', bestOverallCost);
fprintf('------------------------------------------------------\n\n');
for t = 1:numTrucks
    target_idx = mod(t-1, size(targetPositions, 1)) + 1;
    parking_spot_coords = parkingSpots(t,:);
    fprintf('--- Mission %d ---\n', t);
    fprintf('  - Target ID:       %d at [%.2f, %.2f] km (local)\n', target_idx, targetPositions_local(target_idx, 1), targetPositions_local(target_idx, 2));
    fprintf('  - Assigned Truck:  Truck %d\n', t);
    fprintf('  - Deployed Drone:  Drone %d\n', t);
    fprintf('  - Optimal Parking: at [%.2f, %.2f] km (world)\n', parking_spot_coords(1), parking_spot_coords(2));
    fprintf('\n  COST ANALYSIS:\n');
    fprintf('    > Truck %d Cost: $%.2f (Travel: $%.2f, Wait: $%.2f)\n', t, final_JTruck_costs(t), final_JTruck_components(t,1), final_JTruck_components(t,2));
    fprintf('    > Drone %d Cost: $%.2f (Time: $%.2f, Battery: $%.2f, Obstacle: $%.2f, Signal: $%.2f)\n', t, final_JDrone_costs(t), final_JDrone_components(t,1), final_JDrone_components(t,2), final_JDrone_components(t,3), final_JDrone_components(t,4));
    fprintf('------------------------------------------------------\n');
end

% =========================================================================
% SECTION 5: RESULTS ANALYSIS & PLOTTING
% =========================================================================
% (This section remains unchanged)
% =========================================================================
truckColors = lines(numTrucks);
fig_ga = figure('Name', 'GA Fitness Convergence', 'NumberTitle', 'off');
plot(1:ga.maxGenerations, bestCostHistory, 'b-', 'LineWidth', 2, 'DisplayName', 'Best Cost ($)'); hold on;
plot(1:ga.maxGenerations, avgCostHistory, 'r--', 'LineWidth', 1.5, 'DisplayName', 'Average Cost ($)');
grid on; xlabel('Generation'); ylabel('Total JTruck Cost ($)'); title('GA Fitness Convergence Over Generations');
legend('Location', 'best');
saveFigure(fig_ga, 'GA_Convergence.png', 600, 12);

fig_boa = figure('Name', 'BOA Fitness Convergence', 'NumberTitle', 'off');
hold on;
for t = 1:numTrucks, plot(1:boa.maxGenerations, final_drone_conv_histories{t}, '-o', 'LineWidth', 1.5, 'DisplayName', sprintf('Drone %d', t)); end
grid on; xlabel('Generation'); ylabel('JDrone Mission Cost ($)'); title('BOA Fitness Convergence for Final Drone Missions');
legend('Location', 'best');
saveFigure(fig_boa, 'BOA_Convergence.png', 600, 12);

fig_cost = figure('Name', 'Cost Component Breakdown', 'NumberTitle', 'off');
bar(1:numTrucks, final_JTruck_components, 'stacked');
grid on; legend('Truck Travel Cost ($)', 'Truck Wait Cost ($)', 'Location', 'bestoutside');
xlabel('Truck ID'); ylabel('Cost Component ($)'); title('Breakdown of Final JTruck Costs');
set(gca, 'XTick', 1:numTrucks, 'XTickLabel', arrayfun(@(x) sprintf('Truck %d', x), 1:numTrucks, 'UniformOutput', false));
saveFigure(fig_cost, 'Cost_Breakdown.png', 600, 12);

fig_percentage = figure('Name', 'Cost Percentage Breakdown', 'NumberTitle', 'off');
total_mission_costs = final_JTruck_costs + final_JDrone_costs;
truck_percentages = (final_JTruck_costs ./ total_mission_costs) * 100;
drone_percentages = (final_JDrone_costs ./ total_mission_costs) * 100;
percentage_data = [truck_percentages, drone_percentages];
b = bar(1:numTrucks, percentage_data, 'stacked', 'BarWidth', 0.6);
grid on; ylim([0 100]); ylabel('Cost Contribution (%)'); xlabel('Mission ID');
title('Truck vs. Drone Cost Contribution per Mission');
set(gca, 'XTick', 1:numTrucks, 'XTickLabel', arrayfun(@(x) sprintf('Mission %d', x), 1:numTrucks, 'UniformOutput', false));
legend('Truck Cost %', 'Drone Mission Cost %', 'Location', 'bestoutside');
for i = 1:size(percentage_data, 1)
    if percentage_data(i,1) > 10, text(b(1).XData(i), b(1).YData(i)/2, sprintf('%.1f%%', b(1).YData(i)), 'HorizontalAlignment', 'center', 'FontWeight', 'bold', 'Color', 'w'); end
    if percentage_data(i,2) > 10, text(b(2).XData(i), b(1).YData(i) + b(2).YData(i)/2, sprintf('%.1f%%', b(2).YData(i)), 'HorizontalAlignment', 'center', 'FontWeight', 'bold', 'Color', 'w'); end
end
saveFigure(fig_percentage, 'Cost_Percentage_Breakdown.png', 600, 12);

% =========================================================================
% SECTION 6: STATIC FINAL STATE VISUALIZATION
% =========================================================================
% (This section remains unchanged)
% =========================================================================
fig_static = figure('Name', 'Static Final Solution', 'NumberTitle', 'off', 'Color', 'w', 'Position', [50, 50, 1200, 600]);
ax1_static = subplot(1, 2, 1); hold on; ax1_static.Color = [0.9 0.9 0.9];
rectangle('Position', [noGo_x_start, noGo_y_start, floorSizeX, floorSizeY], 'FaceColor', [0.5 0.5 0.5], 'EdgeColor', 'k');
axis on; grid on; title('Lower-Level: Final Truck Route'); xlabel('X (km)'); ylabel('Y (km)'); axis([0 worldSizeX 0 worldSizeY]);
scatter(truckNetworkNodes(:, 1), truckNetworkNodes(:, 2), 50, 'b', 'filled', 'MarkerFaceAlpha', 0.8, 'DisplayName', 'Network Nodes');
scatter(parkingSpots(:, 1), parkingSpots(:, 2), 100, 'r', 'filled', 'Marker', 's', 'DisplayName', 'Parking Spots');
scatter(depotLocation(1), depotLocation(2), 200, 'k', 'filled', 'Marker', 'd', 'DisplayName', 'Depot');
for t = 1:numTrucks, if ~isempty(final_truck_paths{t}), plot(final_truck_paths{t}(:,1), final_truck_paths{t}(:,2), '--', 'LineWidth', 2, 'Color', truckColors(t,:), 'DisplayName', sprintf('Truck %d Route', t)); end; end
scatter(targetPositions(:, 1), targetPositions(:, 2), 150, 'g', 'filled', 'Marker', 'p', 'DisplayName', 'Targets');
patch(NaN, NaN, [0.5 0.5 0.5], 'EdgeColor', 'k', 'DisplayName', 'No-Go Zone');
legend('Location', 'bestoutside'); hold off;
ax2_static = subplot(1, 2, 2); title('Upper-Level: Final Drone Trajectory'); xlabel('X (km)'); ylabel('Y (km)'); zlabel('Z (km)'); grid on; hold on;
all_drone_points_local = [parkingSpots - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone]; targetPositions_local];
x_min = min(all_drone_points_local(:,1)) - 0.5; x_max = max(all_drone_points_local(:,1)) + 0.5;
y_min = min(all_drone_points_local(:,2)) - 0.5; y_max = max(all_drone_points_local(:,2)) + 0.5;
axis(ax2_static, [x_min, x_max, y_min, y_max, 0, droneCruiseAltitude * 1.6]); view(3);
scatter3(ax2_static, xOffset_drone, yOffset_drone, droneCruiseAltitude, 200, 'm', 'filled', 'Marker', '^', 'DisplayName', 'Tower');
scatter3(ax2_static, targetPositions_local(:,1), targetPositions_local(:,2), zeros(numTargets,1), 150, 'g', 'p', 'filled', 'DisplayName', 'Targets');
for t = 1:numTrucks, if ~isempty(final_drone_paths{t}), plot3(ax2_static, final_drone_paths{t}(:,1), final_drone_paths{t}(:,2), final_drone_paths{t}(:,3), 'Color', truckColors(t,:), 'LineWidth', 2, 'DisplayName', sprintf('Drone %d Path', t)); end; end
for i = 1:length(obstacles)
    obs=obstacles(i); x=(obs.x-1)*gridResolution; y=(obs.y-1)*gridResolution; w=obs.w*gridResolution; h=obs.h*gridResolution; z=obs.z;
    vertices = [x,y,0; x+w,y,0; x+w,y+h,0; x,y+h,0; x,y,z; x+w,y,z; x+w,y+h,z; x,y+h,z]; faces = [1,2,3,4; 5,6,7,8; 1,2,6,5; 2,3,7,6; 3,4,8,7; 4,1,5,8];
    if i == 1, patch(ax2_static, 'Vertices',vertices, 'Faces',faces, 'FaceColor',[0.3 0.3 0.3], 'EdgeColor','k', 'FaceAlpha',0.8, 'DisplayName', 'Obstacles');
    else, patch(ax2_static, 'Vertices',vertices, 'Faces',faces, 'FaceColor',[0.3 0.3 0.3], 'EdgeColor','k', 'FaceAlpha',0.8, 'HandleVisibility', 'off'); end
end
legend(ax2_static, 'Location', 'best'); hold off;
saveFigure(fig_static, 'Final_Solution_Overview.png', 600, 12);

% =========================================================================
% SECTION 7: SIMULATION ANIMATION
% =========================================================================
% (This section remains unchanged)
% =========================================================================
SAVE_ANIMATION = true; % TUNABLE: Set to true to save video and GIF
fprintf('Starting simulation animation...\n');
anim_fig = figure('Name', 'Live Simulation Animation', 'NumberTitle', 'off', 'Color', 'w', 'Position', [150, 150, 1200, 600]);
if SAVE_ANIMATION, video_filename = 'simulation_video.mp4'; v = VideoWriter(video_filename, 'MPEG-4'); v.Quality = 100; v.FrameRate = 20; open(v); gif_filename = 'simulation_animation.gif'; end
ax1_anim = subplot(1, 2, 1); hold on; ax1_anim.Color = [0.9 0.9 0.9]; rectangle('Position', [noGo_x_start, noGo_y_start, floorSizeX, floorSizeY], 'FaceColor', [0.5 0.5 0.5], 'EdgeColor', 'k');
axis on; grid on; title('Lower-Level: Truck Movement'); xlabel('X (km)'); ylabel('Y (km)'); axis([0 worldSizeX 0 worldSizeY]);
scatter(ax1_anim, truckNetworkNodes(:, 1), truckNetworkNodes(:, 2), 50, 'b', 'filled', 'MarkerFaceAlpha', 0.2); scatter(ax1_anim, parkingSpots(:, 1), parkingSpots(:, 2), 100, 'r', 'filled', 'Marker', 's');
scatter(ax1_anim, depotLocation(1), depotLocation(2), 200, 'k', 'filled', 'Marker', 'd'); scatter(ax1_anim, targetPositions(:,1), targetPositions(:,2), 150, 'g', 'p', 'filled');
for t = 1:numTrucks, if ~isempty(final_truck_paths{t}), plot(ax1_anim, final_truck_paths{t}(:,1), final_truck_paths{t}(:,2), '--', 'Color', [truckColors(t,:), 0.3]); end; end
ax2_anim = subplot(1, 2, 2); hold on; grid on; title('Upper-Level: Drone Movement'); xlabel('X (km)'); ylabel('Y (km)'); zlabel('Z (km)'); axis(ax2_anim, [x_min, x_max, y_min, y_max, 0, droneCruiseAltitude * 1.6]); view(3);
for i = 1:length(obstacles)
    obs=obstacles(i); x=(obs.x-1)*gridResolution; y=(obs.y-1)*gridResolution; w=obs.w*gridResolution; h=obs.h*gridResolution; z=obs.z;
    vertices = [x,y,0; x+w,y,0; x+w,y+h,0; x,y+h,0; x,y,z; x+w,y,z; x+w,y+h,z; x,y+h,z]; faces = [1,2,3,4; 5,6,7,8; 1,2,6,5; 2,3,7,6; 3,4,8,7; 4,1,5,8];
    patch(ax2_anim, 'Vertices',vertices, 'Faces',faces, 'FaceColor',[0.3 0.3 0.3], 'EdgeColor','k', 'FaceAlpha',0.7);
end
scatter3(ax2_anim, targetPositions_local(:,1), targetPositions_local(:,2), zeros(numTargets,1), 150, 'g', 'p', 'filled');
for t = 1:numTrucks, if ~isempty(final_drone_paths{t}), plot3(ax2_anim, final_drone_paths{t}(:,1), final_drone_paths{t}(:,2), final_drone_paths{t}(:,3), '--', 'Color', [truckColors(t,:), 0.3]); end; end
truck_trajectories = cell(numTrucks, 1); drone_trajectories = cell(numTrucks, 1); max_time = 0;
for t = 1:numTrucks
    if ~isempty(final_truck_paths{t})
        path = final_truck_paths{t}; dist_segments = vecnorm(diff(path, 1, 1), 2, 2); cum_dist = [0; cumsum(dist_segments)];
        truck_time = cum_dist / truckSpeed; truck_trajectories{t} = {truck_time, path}; truck_arrival_time = truck_time(end);
        startPos_local = parkingSpots(t,:) - [xOffset_truck - xOffset_drone, yOffset_truck - yOffset_drone]; targetPos_local = targetPositions(mod(t-1,size(targetPositions,1))+1,:) - [xOffset_truck-xOffset_drone, yOffset_truck-yOffset_drone];
        [pathXY_local, ~] = AStarPath(inflatedMap_drone, startPos_local, targetPos_local, droneDiagFlightEnabled, floorSizeX, floorSizeY, false);
        [dronePath, droneTime] = simulateDroneFlight(startPos_local, targetPos_local, final_drone_params{t}, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap_drone, [xOffset_drone,yOffset_drone], R1,R2,k1,k2, pathXY_local, droneDiagFlightEnabled);
        droneTime = droneTime + truck_arrival_time; drone_trajectories{t} = {droneTime, dronePath};
        if ~isempty(droneTime) && droneTime(end) > max_time, max_time = droneTime(end); end
        if truck_arrival_time > max_time, max_time = truck_arrival_time; end
    end
end
h_truck_pos=gobjects(numTrucks,1); h_drone_pos=gobjects(numDrones,1); h_truck_trail=gobjects(numTrucks,1); h_drone_trail=gobjects(numDrones,1);
for t=1:numTrucks, h_truck_pos(t)=plot(ax1_anim,NaN,NaN,'o','MarkerFaceColor',truckColors(t,:),'MarkerSize',10); h_truck_trail(t)=animatedline(ax1_anim,'Color',truckColors(t,:),'LineWidth',1.5); h_drone_pos(t)=plot3(ax2_anim,NaN,NaN,NaN,'p','MarkerFaceColor',truckColors(t,:),'MarkerSize',12); h_drone_trail(t)=animatedline(ax2_anim,'Color',truckColors(t,:),'LineWidth',1.5); end
time_title = sgtitle(anim_fig, 'Simulation Time: 0.00 hours');
dt = 1/3600 * 10; % Animate in 10-second increments
for current_time = 0:dt:max_time
    for t = 1:numTrucks
        if ~isempty(truck_trajectories{t})
            truck_time_vec = truck_trajectories{t}{1}; truck_path_coords = truck_trajectories{t}{2};
            if current_time <= truck_time_vec(end), pos = interp1(truck_time_vec, truck_path_coords, current_time); set(h_truck_pos(t), 'XData', pos(1), 'YData', pos(2)); addpoints(h_truck_trail(t), pos(1), pos(2));
            else, set(h_truck_pos(t), 'XData', truck_path_coords(end,1), 'YData', truck_path_coords(end,2)); end
        end
        if ~isempty(drone_trajectories{t})
            drone_time_vec = drone_trajectories{t}{1}; drone_path_coords = drone_trajectories{t}{2};
            if current_time >= drone_time_vec(1) && current_time <= drone_time_vec(end), pos3d = interp1(drone_time_vec, drone_path_coords, current_time); set(h_drone_pos(t), 'XData', pos3d(1), 'YData', pos3d(2), 'ZData', pos3d(3)); addpoints(h_drone_trail(t), pos3d(1), pos3d(2), pos3d(3));
            elseif current_time > drone_time_vec(end), set(h_drone_pos(t), 'XData', drone_path_coords(end,1), 'YData', drone_path_coords(end,2), 'ZData', drone_path_coords(end,3)); end
        end
    end
    set(time_title, 'String', sprintf('Simulation Time: %.2f minutes', current_time * 60));
    drawnow;
    if SAVE_ANIMATION, frame = getframe(anim_fig); writeVideo(v, frame); im = frame2im(frame); [imind, cm] = rgb2ind(im, 256); if abs(current_time) < 1e-6, imwrite(imind, cm, gif_filename, 'gif', 'Loopcount', inf, 'DelayTime', dt*10); else, imwrite(imind, cm, gif_filename, 'gif', 'WriteMode', 'append', 'DelayTime', dt*10); end; end
end
set(time_title, 'String', sprintf('Simulation Complete! Total Time: %.2f minutes', max_time * 60));
fprintf('Animation finished.\n');
if SAVE_ANIMATION, close(v); fprintf('Animation saved to %s and %s\n', video_filename, gif_filename); end

% =========================================================================
% SECTION 8: TRUCK NETWORK GRAPH VISUALIZATION
% =========================================================================
fig_network = figure('Name', 'Truck Network Graph', 'NumberTitle', 'off');
hold on; ax_nodes = gca; ax_nodes.Color = [0.9 0.9 0.9]; 
rectangle('Position', [noGo_x_start, noGo_y_start, floorSizeX, floorSizeY], 'FaceColor', [0.5 0.5 0.5], 'EdgeColor', 'k');
grid on;
for i = 1:numNodes, for j = i+1:numNodes, plot([truckNetworkNodes(i, 1), truckNetworkNodes(j, 1)], [truckNetworkNodes(i, 2), truckNetworkNodes(j, 2)], ':', 'Color', [0.5 0.5 0.5], 'HandleVisibility', 'off'); end; end
scatter(depotLocation(1), depotLocation(2), 200, 'k', 'd', 'filled', 'DisplayName', 'Depot');
scatter(truckNetworkNodes(:, 1), truckNetworkNodes(:, 2), 70, 'b', 'o', 'filled', 'DisplayName', 'All Network Nodes');
scatter(parkingSpots(:, 1), parkingSpots(:, 2), 150, 'r', 's', 'filled', 'DisplayName', 'Selected Parking Spots');
for i = 1:numParkingSpots, text(parkingSpots(i, 1) + 0.1, parkingSpots(i, 2) + 0.1, sprintf('P%d', i), 'FontSize', 12, 'FontWeight', 'bold', 'Color', 'r'); end
patch(NaN, NaN, [0.5 0.5 0.5], 'EdgeColor', 'k', 'DisplayName', 'No-Go Zone');
title('Truck Network Nodes and Optimized Parking Spots'); xlabel('X (km)'); ylabel('Y (km)');
legend('show', 'Location', 'bestoutside'); axis equal; axis([0 worldSizeX 0 worldSizeY]); hold off;
saveFigure(fig_network, 'Truck_Network_Graph.png', 600, 12);

% =========================================================================
% SECTION 9: SAVE RESULTS 
% =========================================================================
save('optimization_results.mat', 'final_truck_paths', 'parkingSpots', 'final_JTruck_costs', 'final_JDrone_costs');
fprintf('\nFinal results have been saved to optimization_results.mat\n');

% =========================================================================
% FUNCTION DEFINITIONS
% =========================================================================
function [bestParams, minCost, costHistory, missionTime, costComponents] = runDroneBat(startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, boa, towerPosition, R1, R2, k1, k2, droneMapX, droneMapY), nVar = 3; varMin = [0.5, 0.5, 0.5]; varMax = [2.0, 2.0, 2.0]; bats = struct('Position', {}, 'Velocity', {}, 'Loudness', {}, 'PulseRate', {}, 'Cost', {}); costHistory=zeros(boa.maxGenerations,1); [pathXY, ~] = AStarPath(gridMap, startPos, targetPos, droneDiagFlightEnabled, droneMapX, droneMapY, false); missionTime = inf; costComponents=[inf,inf,inf,inf]; if isempty(pathXY), minCost = 1e10; bestParams = [1, 1, 1]; costHistory(:)=minCost; return; end; for i = 1:boa.populationSize, bats(i).Position = varMin + (varMax - varMin).* rand(1, nVar); bats(i).Velocity = zeros(1, nVar); bats(i).Loudness = boa.loudness; bats(i).PulseRate = boa.pulseRate; try, [bats(i).Cost, ~] = JDroneCost(bats(i).Position, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); catch, bats(i).Cost = 1e10; end; end; [minCost, bestBatIdx] = min([bats.Cost]); bestParams = bats(bestBatIdx).Position; for gen = 1:boa.maxGenerations, for i = 1:boa.populationSize, newF = boa.fmin + (boa.fmax - boa.fmin) * rand; bats(i).Velocity = bats(i).Velocity + (bats(i).Position - bestParams) * newF; newPos = bats(i).Position + bats(i).Velocity; newPos = max(newPos, varMin); newPos = min(newPos, varMax); if rand > bats(i).PulseRate, newPos = bestParams + 0.1 * randn(1, nVar); newPos = max(newPos, varMin); newPos = min(newPos, varMax); end; try, [newCost, ~] = JDroneCost(newPos, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); catch, newCost = 1e10; end; if newCost < bats(i).Cost && rand < bats(i).Loudness, bats(i).Position = newPos; bats(i).Cost = newCost; bats(i).Loudness = bats(i).Loudness * 0.9; bats(i).PulseRate = boa.pulseRate * (1 - exp(-gen/boa.maxGenerations)); end; end; [minCost, bestBatIdx] = min([bats.Cost]); bestParams = bats(bestBatIdx).Position; costHistory(gen)=minCost; end; [minCost, missionTime, costComponents] = JDroneCost(bestParams, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY); end
function [costVal, totalTime, components] = JDroneCost(params, startPos, targetPos, gridMap, cost, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneDiagFlightEnabled, droneStayTime, droneBatteryMin, initialBattery, towerPosition, R1, R2, k1, k2, pathXY), [~, droneTimeVec, ~, batteryConsumptionPerStep, obstaclePenaltySum, signalPenaltySum] = simulateDroneFlight(startPos, targetPos, params, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap, towerPosition, R1, R2, k1, k2, pathXY, droneDiagFlightEnabled); if isempty(droneTimeVec), totalTime = inf; else, totalTime = droneTimeVec(end); end; timeCost = totalTime * cost.dronePerHour; obstacleCost = obstaclePenaltySum * cost.obstaclePenalty; remainingBattery = initialBattery - cumsum(batteryConsumptionPerStep); remainingBattery(remainingBattery < droneBatteryMin) = droneBatteryMin; batteryUsageIntegral = sum(1 ./ remainingBattery); batteryCost = batteryUsageIntegral * cost.batteryPenalty; signalCost = signalPenaltySum * cost.signalPenalty; costVal = timeCost + obstacleCost + batteryCost + signalCost; components = [timeCost, batteryCost, obstacleCost, signalCost]; end
function [path_meters, totalDistance] = AStarPath(gridMap, startPos, targetPos, diagEnabled, worldX, worldY, debug_flag), if nargin < 7, debug_flag = false; end; if debug_flag, fprintf('\n--- A* Debug Start ---\n'); fprintf('Attempting to find path from [%.2f, %.2f] to [%.2f, %.2f]\n', startPos(1), startPos(2), targetPos(1), targetPos(2)); end; [rows, cols] = size(gridMap); gridResolution_x = worldX / cols; gridResolution_y = worldY / rows; startIdx = floor(startPos ./ [gridResolution_x, gridResolution_y]) + 1; targetIdx = floor(targetPos ./ [gridResolution_x, gridResolution_y]) + 1; startIdx(1) = max(1, min(cols, startIdx(1))); startIdx(2) = max(1, min(rows, startIdx(2))); targetIdx(1) = max(1, min(cols, targetIdx(1))); targetIdx(2) = max(1, min(rows, targetIdx(2))); if debug_flag, fprintf('Start Index: [%d, %d], Target Index: [%d, %d]\n', startIdx(1), startIdx(2), targetIdx(1), targetIdx(2)); end; if gridMap(startIdx(2), startIdx(1)) == 1 || gridMap(targetIdx(2), targetIdx(1)) == 1, if debug_flag, fprintf('A* Error: Start or Target is inside an obstacle.\n'); end; path_meters = []; totalDistance = inf; return; end; openSet = priority_queue(); openSet.insert(startIdx, 0); gScore = inf(rows, cols); gScore(startIdx(2), startIdx(1)) = 0; cameFrom = zeros(rows, cols, 2); path = []; while ~openSet.isempty(), currentIdx = openSet.extract_min(); if isequal(currentIdx, targetIdx), path = []; current = currentIdx; while ~isequal(current, startIdx), path = [path; current]; current = squeeze(cameFrom(current(2), current(1), :))'; end; path = [path; startIdx]; path = flipud(path); break; end; neighbors = getNeighbors(currentIdx, diagEnabled, rows, cols); for i = 1:size(neighbors, 1), neighbor = neighbors(i, :); if neighbor(1) < 1 || neighbor(1) > cols || neighbor(2) < 1 || neighbor(2) > rows, continue; end; if gridMap(neighbor(2), neighbor(1)) == 1, continue; end; dist = norm((currentIdx - neighbor) .* [gridResolution_x, gridResolution_y]); tentative_gScore = gScore(currentIdx(2), currentIdx(1)) + dist; if tentative_gScore < gScore(neighbor(2), neighbor(1)), cameFrom(neighbor(2), neighbor(1), :) = currentIdx; gScore(neighbor(2), neighbor(1)) = tentative_gScore; hScore = norm((neighbor - targetIdx) .* [gridResolution_x, gridResolution_y]); fScore = tentative_gScore + hScore; if ~openSet.contains(neighbor), openSet.insert(neighbor, fScore); end; end; end; end; if isempty(path), if debug_flag, fprintf('A* Failure: No path found.\n'); end; path_meters = []; totalDistance = inf; else, if debug_flag, fprintf('A* Success: Path found with %d points.\n', size(path, 1)); end; path_meters = (path - 1) .* [gridResolution_x, gridResolution_y]; totalDistance = 0; for i = 1:size(path_meters, 1) - 1, totalDistance = totalDistance + norm(path_meters(i, :) - path_meters(i+1, :)); end; end; if debug_flag, fprintf('--- A* Debug End ---\n'); end; end
function neighbors = getNeighbors(node, diagEnabled, rows, cols), [x, y] = deal(node(1), node(2)); neighbors = []; if x > 1, neighbors = [neighbors; [x-1, y]]; end; if x < cols, neighbors = [neighbors; [x+1, y]]; end; if y > 1, neighbors = [neighbors; [x, y-1]]; end; if y < rows, neighbors = [neighbors; [x, y+1]]; end; if diagEnabled, if x > 1 && y > 1, neighbors = [neighbors; [x-1, y-1]]; end; if x < cols && y > 1, neighbors = [neighbors; [x+1, y-1]]; end; if x > 1 && y < rows, neighbors = [neighbors; [x-1, y+1]]; end; if x < cols && y < rows, neighbors = [neighbors; [x+1, y+1]]; end; end; end
function [dronePath, droneTime, totalDistance, batteryConsumptionPerStep, obstaclePenaltySum, signalPenaltySum] = simulateDroneFlight(startPos, targetPos, params, droneCruiseAltitude, droneSpeed_H, droneSpeed_V, droneStayTime, gridMap, towerPosition, R1, R2, k1, k2, pathXY, droneDiagFlightEnabled), h_vel_scale = params(1); v_vel_scale_ascent = params(2); v_vel_scale_descent = params(3); gridResolution = 0.1; ascentSpeed = droneSpeed_V * v_vel_scale_ascent; ascentTime = droneCruiseAltitude / ascentSpeed; numStepsAscent = max(2, round(ascentTime / (gridResolution/droneSpeed_V))); z_ascent = linspace(0, droneCruiseAltitude, numStepsAscent); path_ascent = [repmat(startPos(1), numStepsAscent, 1), repmat(startPos(2), numStepsAscent, 1), z_ascent']; time_ascent = linspace(0, ascentTime, numStepsAscent)'; horizSpeed = droneSpeed_H * h_vel_scale; path_horiz = [pathXY, repmat(droneCruiseAltitude, size(pathXY,1), 1)]; if size(pathXY, 1) > 1, dist_segments = vecnorm(diff(pathXY, 1, 1), 2, 2); time_segments = dist_segments / horizSpeed; time_horiz = [0; cumsum(time_segments)]; else, time_horiz = 0; end; descentSpeed = droneSpeed_V * v_vel_scale_descent; descentTime = droneCruiseAltitude / descentSpeed; numStepsDescent = max(2, round(descentTime / (gridResolution/droneSpeed_V))); z_descent = linspace(droneCruiseAltitude, 0, numStepsDescent); path_descent = [repmat(targetPos(1), numStepsDescent, 1), repmat(targetPos(2), numStepsDescent, 1), z_descent']; time_descent = linspace(0, descentTime, numStepsDescent)'; dronePath = path_ascent; droneTime = time_ascent; if size(path_horiz, 1) > 1, dronePath = [dronePath; path_horiz(2:end, :)]; droneTime = [droneTime; droneTime(end) + time_horiz(2:end)]; end; dronePath = [dronePath; path_descent(2:end, :)]; droneTime = [droneTime; droneTime(end) + time_descent(2:end)]; dronePath = [dronePath; dronePath(end,:)]; droneTime = [droneTime; droneTime(end) + droneStayTime]; totalDistance = 0; if size(dronePath, 1) > 1, for i = 1:size(dronePath, 1) - 1, totalDistance = totalDistance + norm(dronePath(i, :) - dronePath(i+1, :)); end; end; batteryConsumptionPerStep = zeros(size(dronePath,1), 1); obstaclePenaltySum = 0; signalPenaltySum = 0; len_ascent_pts = size(path_ascent, 1); len_horiz_pts = size(path_horiz, 1); if isempty(pathXY), len_horiz_pts = 0; end; for i = 1:size(dronePath, 1), currentPos_2D = dronePath(i, 1:2); gridX_curr = floor(currentPos_2D(1)/gridResolution)+1; gridY_curr = floor(currentPos_2D(2)/gridResolution)+1; gridX_curr=max(1,min(size(gridMap,2),gridX_curr)); gridY_curr=max(1,min(size(gridMap,1),gridY_curr)); if gridMap(gridY_curr, gridX_curr) == 1, obstaclePenaltySum = obstaclePenaltySum + 1; end; distToTower = norm(currentPos_2D - towerPosition); if distToTower > R2, signalPenaltySum=signalPenaltySum+k2; elseif distToTower > R1, signalPenaltySum=signalPenaltySum+k1*(distToTower-R1)^2; end; len_horiz_segment = max(0, len_horiz_pts - 1); if i <= len_ascent_pts, batt_step = 0.01 + 0.005 * v_vel_scale_ascent; elseif i <= len_ascent_pts + len_horiz_segment, batt_step = 0.01 + 0.005 * h_vel_scale; else, batt_step = 0.01 + 0.005 * v_vel_scale_descent; end; batteryConsumptionPerStep(i) = batt_step; end; end
function saveFigure(figHandle, filename, dpi, fontsize), set(findall(figHandle, '-property', 'FontSize'), 'FontSize', fontsize); exportgraphics(figHandle, filename, 'Resolution', dpi); fprintf('Figure saved to %s\n', filename); end